Misc.:

* [ ] Program

Directives:

* [ ] Use definition
* [ ] Class definition
* [ ] Enum definition
* [ ] Interface definition
* [ ] Type definition
* [ ] Variable definition
* [ ] Function definition
* [ ] Getter definition
* [ ] Setter definition
* [ ] Module definition
* [ ] Namespace definition
* [ ] `use escaped.name = definitionOrValue;`

Statements:

* [ ] Super statement
* [ ] Block
* [ ] If statement
* [ ] Switch statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] statement
* [ ] Try statement

Expressions:

* [ ] Identifier
* [ ] BooleanLiteral
* [ ] NumericLiteral
* [ ] StringLiteral
* [ ] ThisLiteral
* [ ] RegExpLiteral
* [ ] ParenExpression
* [ ] ArrayInitialiser
* [ ] ObjectInitialiser
* [ ] FunctionExpression
* [ ] SuperExpression
* [ ] CallExpression
* [ ] UnaryExpression
* [ ] BinaryExpression
  * The right-hand side is always any expression and not a type expression. Actual type expressions can be used through type aliases.
* [ ] MemberExpression
* [ ] NewExpression
* [ ] ListExpression
* [ ] ConditionalExpression
* [ ] AssignmentExpression
  * The left-hand side may be a destructuring pattern.
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] 
* [ ] Try expression
  * [ ] Parsing: `lookahead != "{"`