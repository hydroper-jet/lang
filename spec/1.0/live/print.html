<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>JetWork Language Specification</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="overview/example-programs.html"><strong aria-hidden="true">1.1.</strong> Example programs</a></li><li class="chapter-item "><a href="overview/package-manager.html"><strong aria-hidden="true">1.2.</strong> Package manager</a></li><li class="chapter-item "><a href="overview/compilation.html"><strong aria-hidden="true">1.3.</strong> Compilation and transpilation</a></li><li class="chapter-item "><a href="overview/string-encoding.html"><strong aria-hidden="true">1.4.</strong> String encoding</a></li><li class="chapter-item "><a href="overview/exceptions.html"><strong aria-hidden="true">1.5.</strong> Exceptions</a></li><li class="chapter-item "><a href="overview/nullability.html"><strong aria-hidden="true">1.6.</strong> Nullability</a></li><li class="chapter-item "><a href="overview/proxy.html"><strong aria-hidden="true">1.7.</strong> Proxy</a></li><li class="chapter-item "><a href="overview/j4x.html"><strong aria-hidden="true">1.8.</strong> JetWork for XML</a></li><li class="chapter-item "><a href="overview/jxml-components.html"><strong aria-hidden="true">1.9.</strong> JXML components</a></li><li class="chapter-item "><a href="overview/jetdoc-comments.html"><strong aria-hidden="true">1.10.</strong> JetDoc comments</a></li></ol></li><li class="chapter-item "><a href="notation.html"><strong aria-hidden="true">2.</strong> Notation</a></li><li class="chapter-item "><a href="lexical-structure.html"><strong aria-hidden="true">3.</strong> Lexical structure</a></li><li class="chapter-item "><a href="types.html"><strong aria-hidden="true">4.</strong> Types</a></li><li class="chapter-item "><a href="type-conversions.html"><strong aria-hidden="true">5.</strong> Type conversions</a></li><li class="chapter-item "><a href="visibility.html"><strong aria-hidden="true">6.</strong> Visibility</a></li><li class="chapter-item "><a href="packages.html"><strong aria-hidden="true">7.</strong> Packages</a></li><li class="chapter-item "><a href="variables.html"><strong aria-hidden="true">8.</strong> Variables</a></li><li class="chapter-item "><a href="virtual-properties.html"><strong aria-hidden="true">9.</strong> Virtual properties</a></li><li class="chapter-item "><a href="functions.html"><strong aria-hidden="true">10.</strong> Functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="functions/instance-methods.html"><strong aria-hidden="true">10.1.</strong> Instance methods</a></li><li class="chapter-item "><a href="functions/interface-methods.html"><strong aria-hidden="true">10.2.</strong> Interface methods</a></li><li class="chapter-item "><a href="functions/getters-and-setters.html"><strong aria-hidden="true">10.3.</strong> Getters and setters</a></li><li class="chapter-item "><a href="functions/constructors.html"><strong aria-hidden="true">10.4.</strong> Constructors</a></li><li class="chapter-item "><a href="functions/proxies.html"><strong aria-hidden="true">10.5.</strong> Proxies</a></li></ol></li><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">11.</strong> Generics</a></li><li class="chapter-item "><a href="metadata.html"><strong aria-hidden="true">12.</strong> Meta-data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="metadata/reserved-metadata.html"><strong aria-hidden="true">12.1.</strong> Reserved meta-data</a></li><li class="chapter-item "><a href="metadata/decorator-metadata.html"><strong aria-hidden="true">12.2.</strong> Decorator meta-data</a></li><li class="chapter-item "><a href="metadata/plain-metadata.html"><strong aria-hidden="true">12.3.</strong> Plain meta-data</a></li></ol></li><li class="chapter-item "><a href="aliases.html"><strong aria-hidden="true">13.</strong> Aliases</a></li><li class="chapter-item "><a href="enum.html"><strong aria-hidden="true">14.</strong> Enumerations</a></li><li class="chapter-item "><a href="classes.html"><strong aria-hidden="true">15.</strong> Classes</a></li><li class="chapter-item "><a href="interfaces.html"><strong aria-hidden="true">16.</strong> Interfaces</a></li><li class="chapter-item "><a href="jxml-components.html"><strong aria-hidden="true">17.</strong> JXML components</a></li><li class="chapter-item "><a href="property-resolution.html"><strong aria-hidden="true">18.</strong> Property resolution</a></li><li class="chapter-item "><a href="scopes.html"><strong aria-hidden="true">19.</strong> Scopes</a></li><li class="chapter-item "><a href="type-expressions.html"><strong aria-hidden="true">20.</strong> Type expressions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">JetWork Language Specification</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p align="center">
  <img alt="JetWork Icon" src="assets/icon.png" width="100">
</p>
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>JetWork is a flexible, productive, robust, strongly typed, object-oriented, multi-purpose scripting language. JetWork is influenced by ActionScript.</p>
<p>This document specifies the language syntax, semantics and execution, but may lack some definitions from the ECMA-262 standard in which it is partially based.</p>
<h2 id="native-extensions"><a class="header" href="#native-extensions">Native extensions</a></h2>
<p>The language allows libraries known as <em>native extensions</em> to be developed through the combination of <a href="metadata/plain-metadata.html">plain meta-data</a> and <a href="overview/package-manager.html#conditional-configuration">conditional configuration</a>.</p>
<p>Plain meta-data allow embedding arbitrary files with binary content, such as dynamic-link libraries, as well as textual files such as application descriptors.</p>
<p>Conditional configuration is used solely at the package manifest of a JetWork project and allows including program sources and dependencies in a conditional way.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-programs"><a class="header" href="#example-programs">Example programs</a></h1>
<h2 id="simple-functions"><a class="header" href="#simple-functions">Simple functions</a></h2>
<pre><code>public function isEven(argument: BigInt): Boolean (
    argument % 2 == 0
);

trace(isEven(11));

// https://en.wikipedia.org/wiki/Heron%27s_formula
public function triangleArea(a: Number, b: Number, c: Number): Number {
    const s = (a + b + c) / 2;
    return (s * (s - a) * (s - b) * (s - c)) ** 0.5;
}

trace(triangleArea(5, 6, 7));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-manager"><a class="header" href="#package-manager">Package manager</a></h1>
<p>The language is integrated with JetPM, a package manager with support for vital features:</p>
<ul>
<li>workspaces;</li>
<li>specifying a dependency through a directory path;</li>
<li>registry namespaces.</li>
</ul>
<h2 id="build-process"><a class="header" href="#build-process">Build process</a></h2>
<p>The package manifest represents a JetWork project, and locates its sources; therefore, the package manager is able to build a project through a simple command such as <code>jetpm build</code>, resulting into a bytecode artifact.</p>
<p>Here is an example package manifest:</p>
<p><strong>package.json</strong></p>
<pre><code class="language-json">{
    &quot;id&quot;: &quot;org.q.f&quot;,
    &quot;version&quot;: &quot;0.1.0&quot;,
    &quot;compilerOptions&quot;: {
        &quot;includeSources&quot;: [&quot;src&quot;]
    }
}
</code></pre>
<h2 id="registry-namespaces"><a class="header" href="#registry-namespaces">Registry namespaces</a></h2>
<p>Registry namespaces are required to distinguish platforms on which the JetWork program executes. Platforms may have incompatible implementations, such as regular expressions, or lacking implementations of certain functions, therefore sharing packages between platforms is not allowed in JetPM.</p>
<p>The package manifest's top-level <code>registryNamespace</code> option is required and indicates the registry namespace to which the package belongs as well as the namespace on which dependencies are found in the package registry.</p>
<p>Here is an example of a potential package manifest that uses <code>http://www.airsdk.dev/2008</code> as its registry namespace:</p>
<p><strong>package.json</strong></p>
<pre><code class="language-json">{
    &quot;id&quot;: &quot;org.q.f&quot;,
    &quot;version&quot;: &quot;0.1.0&quot;,
    &quot;registryNamespace&quot;: &quot;http://www.airsdk.dev/2008&quot;,
    &quot;dependencies&quot;: {
        &quot;goog.firebase&quot;: &quot;1.0.0&quot;
    }
}
</code></pre>
<p>Note that registry namespaces are defined internally in the registry and may not be arbitrary. Registry namespaces are available as platforms are supported.</p>
<h2 id="conditional-configuration"><a class="header" href="#conditional-configuration">Conditional configuration</a></h2>
<p>The package manager supports configuration constants that allow for conditional configuration within a manifest through the top-level <code>conditional</code> property. The matching options are combined and overriden properly in top-down sequence, including the program sources and the package dependencies.</p>
<p>The conditions in <code>conditional</code> support a minimal conditional language:</p>
<ul>
<li><code>constant</code> — If constant is present</li>
<li><code>constant=value</code> — If constant is equals <code>&quot;value&quot;</code></li>
<li><code>!expression</code> — If condition is false</li>
<li><code>(expression)</code> — Parenthesized condition</li>
<li><code>primaryExpression &amp;&amp; primaryExpression</code> — If conditions are true</li>
<li><code>primaryExpression || primaryExpression</code> — If one condition is true</li>
<li>The root condition is in one of the forms:
<ul>
<li><code>always</code></li>
<li><code>if (condition)</code></li>
<li><code>else if (condition)</code></li>
<li><code>else</code></li>
</ul>
</li>
</ul>
<p>Here is an example package manifest using the <code>conditional</code> setting:</p>
<p><strong>package.json</strong></p>
<pre><code class="language-json">{
    &quot;conditional&quot;: [
        [&quot;always&quot;, {
            &quot;compilerOptions&quot;: {
                &quot;includeSources&quot;: [&quot;src/base&quot;]
            }
        }],
        [&quot;if (air::target=ios)&quot;, {
            &quot;compilerOptions&quot;: {
                &quot;includeSources&quot;: [&quot;src/platform/ios&quot;]
            }
        }],
        [&quot;else&quot;, {
            &quot;compilerOptions&quot;: {
                &quot;includeSources&quot;: [&quot;src/platform/unsupported&quot;]
            }
        }],
        [&quot;always&quot;, {
            &quot;compilerOptions&quot;: {
                &quot;includeSources&quot;: [&quot;src/facade&quot;]
            }
        }]
    ]
}
</code></pre>
<p>Here are example JetPM commands passing configuration constants:</p>
<pre><code class="language-plain">jetpm build --define someConstant
jetpm build --define air::target=ios
</code></pre>
<h2 id="build-script"><a class="header" href="#build-script">Build script</a></h2>
<p>The package manifest allows build scripts to be specified, as well as their dependencies.</p>
<p>Build scripts are executed in the Node.js® platform; therefore they implicitly use the <code>http://www.nodejs.org/2009</code> registry namespace.</p>
<p>Build scripts can be specified both inside the top-level and inside conditional configurations.</p>
<p>Here is an example manifest demonstrating build scripts:</p>
<p><strong>package.json</strong></p>
<pre><code class="language-json">{
    &quot;buildScript&quot;: {
        &quot;compilerOptions&quot;: {
            &quot;includeSources&quot;: [&quot;build.jet&quot;]
        }
    }
}
</code></pre>
<h2 id="workspaces"><a class="header" href="#workspaces">Workspaces</a></h2>
<p>A workspace project contains a <code>workspace.json</code> file, which follows the format:</p>
<p><strong>workspace.json</strong></p>
<pre><code class="language-json">{
    &quot;members&quot;: [
        &quot;packages/com.c.s.p1&quot;,
        &quot;packages/com.c.s.p2&quot;
    ]
}
</code></pre>
<p>A member package may depend in another member package by using a <code>file:</code> URL:</p>
<p><strong>package.json</strong></p>
<pre><code class="language-json">{
    &quot;dependencies&quot;: {
        &quot;com.c.s.p1&quot;: &quot;file:../com.c.s.p1&quot;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilation-and-transpilation"><a class="header" href="#compilation-and-transpilation">Compilation and transpilation</a></h1>
<p>JetWork compiles to the JetWork Virtual Machine Bytecode, which, in turn, can be compiled to other languages or be executed by a virtual machine.</p>
<p>JetWork can be both compiled to native code and transpiled to another object-oriented high-level language.</p>
<h2 id="number-overflow"><a class="header" href="#number-overflow">Number overflow</a></h2>
<p>Operations whose result cannot be represented due to range limit cause a number overflow, such as <code>Int.MAX_VALUE + 1</code>. The result of a number overflow is implementation defined.</p>
<h2 id="platform-specific-operations"><a class="header" href="#platform-specific-operations">Platform-specific operations</a></h2>
<p>It is allowed for platforms that compile the bytecode form into another form to define specific external operations as <code>native</code> functions.</p>
<p>For example, for interoperability between the JetWork and Lua languages during a transpilation process, it may be required to support specific operations to compute table indices and access the Lua environment.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-encoding"><a class="header" href="#string-encoding">String encoding</a></h1>
<p>The String data type uses an implementation-defined encoding and is supported by a <code>CharIndex</code> data type representing an index into a <code>String</code>.</p>
<h2 id="slicing"><a class="header" href="#slicing">Slicing</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method call</th><th>Description</th></tr></thead><tbody>
<tr><td><code>string.slice(string.firstIndex.next(1))</code></td><td>Slices string from second character</td></tr>
<tr><td><code>string.slice(0, string.firstIndex.next(3))</code></td><td>Takes first three characters from a string</td></tr>
<tr><td><code>string.slice(0, string.lastIndex.next(-4))</code></td><td>Slices string until last 4 characters</td></tr>
</tbody></table>
</div>
<h2 id="characters"><a class="header" href="#characters">Characters</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method call</th><th>Description</th></tr></thead><tbody>
<tr><td><code>string.chars().length()</code></td><td>The character count</td></tr>
<tr><td><code>string.length</code></td><td>The string length in the encoding units. For UTF-8, it is the number of bytes.</td></tr>
<tr><td><code>string.isEmpty</code>, <code>string == &quot;&quot;</code></td><td>Whether the string is empty or not</td></tr>
</tbody></table>
</div>
<h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody>
<tr><td><code>string.charAt(i)</code></td><td>Character at <em>i</em></td></tr>
<tr><td><code>for each (const ch in string) {}</code></td><td>Iterates every character</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h1>
<p>JetWork supports throwing errors as in Java, in the form of unchecked exceptions that may occur during program execution.</p>
<pre><code>function task(): void {
    throw new RangeError(&quot;Error&quot;)
}
try {
    doSomething()
} catch (error: RangeError) {
    doSomething()
}
</code></pre>
<p>Documentation comments use the <code>@throws</code> tag to document thrown errors, as in:</p>
<pre><code>package com.mrrunner {
    /**
     * @throws com.mrrunner.MrRunnerError Thrown when run is a failure.
     */
    public function run(): void {
        /* ... */
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullability"><a class="header" href="#nullability">Nullability</a></h1>
<p>The <code>Optional.&lt;T&gt;</code> class is the primary way of working with nullable data.</p>
<ul>
<li>The nullish coalescing operator returns the right operand if the left operand is <code>undefined</code>.</li>
</ul>
<pre><code>public class ExampleClass {
    public const data: Optional.&lt;Number&gt;;
    public function ExampleClass(data: Optional.&lt;Number&gt;) {
        this.data = data;
    }
    public function doubleIt(): ExampleClass (
        new ExampleClass((this.data ?? 0) * 2)
    );
}
// 0
trace(new ExampleClass(undefined).doubleIt().data);
// 20
trace(new ExampleClass(10).doubleIt().data);
</code></pre>
<ul>
<li>The non-null operator ensures the operand is not <code>undefined</code>.</li>
</ul>
<pre><code>// TypeError
trace(new ExampleClass(undefined).data!);
</code></pre>
<ul>
<li>For <code>Optional.&lt;T&gt;</code>, the optional chaining operator returns <code>undefined</code> if the operand is <code>undefined</code>.</li>
</ul>
<pre><code>public function process(a: Optional.&lt;Number&gt;): Optional.&lt;String&gt; (
    a?.toString(16)
);
</code></pre>
<h2 id="transparency"><a class="header" href="#transparency">Transparency</a></h2>
<p>The representation of the <code>Optional.&lt;T&gt;</code> type varies across implementations:</p>
<ul>
<li>The <code>Optional.&lt;T&gt;</code> type is equivalent to a nullable reference as in ActionScript.
<ul>
<li>ActionScript transpilation may consider interning primitive values into a weak dictionary.</li>
</ul>
</li>
<li>The <code>v is Optional.&lt;T&gt;</code> expression has implementation-defined behavior. Programmers should not rely on such expression.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proxy"><a class="header" href="#proxy">Proxy</a></h1>
<p>JetWork operators can be customized through <em>proxies</em>.</p>
<p>Proxies are special methods defined with the <code>proxy</code> attribute. Here is an example class that overrides the addition operator:</p>
<pre><code>public final class AdditiveExample {
    public const value: Number;
    public function AdditiveExample(value: Number) {
        this.value = value;
    }
    proxy function add(right: AdditiveExample): AdditiveExample (
        new AdditiveExample(this.value + right.value);
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jetwork-for-xml"><a class="header" href="#jetwork-for-xml">JetWork for XML</a></h1>
<p>JetWork for XML (J4X) adds XML capabilities to the JetWork language. It is based on the legacy ECMAScript for XML standard (ECMA-357 second edition).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jxml-components"><a class="header" href="#jxml-components">JXML components</a></h1>
<p>JetWork supports classes in XML form called <em>JXML</em> components. A JXML component is a file with the extension <code>.jxml</code>.</p>
<p>Here is an example JXML:</p>
<pre><code class="language-xml">&lt;k:Container xmlns:k=&quot;org.k&quot; className=&quot;org.example.Example&quot;&gt;
    &lt;Script&gt;
        &lt;![CDATA[
            public var exampleProperty: Number = Infinity;
        ]]&gt;
    &lt;/Script&gt;
    &lt;k:Container&gt;
        &lt;k:AnotherExample/&gt;
    &lt;/k:Container&gt;
&lt;/k:Container&gt;
</code></pre>
<p>For the above example, <code>k:Container</code> inherits from the following abstract <code>Node</code> class from <code>org.k</code>:</p>
<pre><code>package org.k {
    public abstract class Node implements JXML { /* ... */ }
}
</code></pre>
<h2 id="data-binding"><a class="header" href="#data-binding">Data binding</a></h2>
<p>JXML may support data binding in the future. Data binding allows transferring the value from an source property to a destination property through an event.</p>
<h2 id="children"><a class="header" href="#children">&lt;Children/&gt;</a></h2>
<p>The empty <code>&lt;Children/&gt;</code> tag may appear anywhere in a JXML file to indicate where to add the tag's children:</p>
<pre><code class="language-xml">&lt;k:Container xmlns:k=&quot;org.k&quot; className=&quot;org.example.Example&quot;&gt;
    &lt;k:Container&gt;
        &lt;k:Container&gt;
            &lt;Children/&gt;
        &lt;/k:Container&gt;
    &lt;/k:Container&gt;
&lt;/k:Container&gt;
</code></pre>
<h2 id="script"><a class="header" href="#script">&lt;Script&gt;</a></h2>
<p>The <code>&lt;Script&gt;</code> tag may appear once in the root of a JXML file to attach code to the class block.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jetdoc-comments"><a class="header" href="#jetdoc-comments">JetDoc comments</a></h1>
<p>JetDoc comments are used to document APIs to the public. JetDoc allows Markdown text to appear within documentation comments and supports special <code>@</code> tags for extended use.</p>
<pre><code>package org.ourdelivery.api {
    /**
     * Delivery options.
     * @example
     * ```
     * import org.ourdelivery.api.*;
     * const options: RequestOptions = {
     *     urgent: true,
     * };
     * ```
     */
    [Literal]
    public class RequestOptions {
        /**
         * Indicates whether the request is *urgent*.
         */
        public var urgent: Boolean;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notation"><a class="header" href="#notation">Notation</a></h1>
<h2 id="grammar-definition"><a class="header" href="#grammar-definition">Grammar definition</a></h2>
<p>This document uses the following notation to define productions of a <em>nonterminal</em> of the grammar:</p>
<table>
    <tr>
        <td colspan="2"><i>NonterminalName</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>Rule1</i> <i>RuleN</i></td>
    </tr>
</table>
<p>Nonterminals followed by the <sub>opt</sub> subscript are optional rules.</p>
<p>A bracketed clause or predicate may appear between the rules of a production, such as in:</p>
<table>
    <tr>
        <td colspan="2"><i>NonterminalName</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td>[lookahead ∈ {<b>0</b>}] <i>Rule1</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td>[lookahead ∉ {<b>default</b>}] <i>Rule2</i></td>
    </tr>
        <td>&nbsp;</td><td><i>SourceCharacters</i> [but no embedded <b>&lt;!&#x5b;CDATA&#x5b;</b>] <i>Rule3</i></td>
    </tr>
</table>
<p>Braces subscripts are used to quantify a rule:</p>
<ul>
<li><i>Rule</i><sub>{4}</sub> — Four of <i>Rule</i></li>
<li><i>Rule</i><sub>{2,}</sub> — At least two of <i>Rule</i></li>
<li><i>Rule</i><sub>{1,4}</sub> — One to four of <i>Rule</i></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexical-structure"><a class="header" href="#lexical-structure">Lexical structure</a></h1>
<table>
    <tr>
        <td colspan="2"><i>InputElementDiv</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>Identifier</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>ReservedWord</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>Punctuator</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>NumericLiteral</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>StringLiteral</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>Comment</i></td>
    </tr>
</table>
<table>
    <tr>
        <td colspan="2"><i>InputElementRegExp</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>Identifier</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>ReservedWord</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>Punctuator</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>/</b></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>/=</b></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>NumericLiteral</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>StringLiteral</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>RegularExpressionLiteral</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>Comment</i></td>
    </tr>
</table>
<h2 id="escape-sequences"><a class="header" href="#escape-sequences">Escape sequences</a></h2>
<table>
    <tr>
        <td colspan="2"><i>UnicodeEscapeSequence</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>&#x5c;u</b> <i>HexDigit</i><sub>{4}</sub></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>&#x5c;u</b> <b>&#x7b;</b> <i>HexDigit</i><sub>{1,}</sub> <b>&#x7d;</b></td>
    </tr>
</table>
<h2 id="identifier"><a class="header" href="#identifier">Identifier</a></h2>
<table>
    <tr>
        <td colspan="2"><i>Identifier</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>IdentifierName</i> [but not <i>ReservedWord</i>]</td>
    </tr>
</table>
<table>
    <tr>
        <td colspan="2"><i>IdentifierName</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>IdentifierStart</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>IdentifierName</i> <i>IdentifierPart</i></td>
    </tr>
</table>
<table>
    <tr>
        <td colspan="2"><i>IdentifierStart</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td>[Letter property (“L”) from Unicode]</td>
    </tr>
    <tr>
        <td>&nbsp;</td><td>[Letter number property (“Nl”) from Unicode]</td>
    </tr>
    <tr>
        <td>&nbsp;</td><td>[Decimal Digit Number property (“Nd”) from Unicode]</td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>_</b></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>$</b></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>UnicodeEscapeSequence</i></td>
    </tr>
</table>
<table>
    <tr>
        <td colspan="2"><i>IdentifierPart</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td>[Letter property (“L”) from Unicode]</td>
    </tr>
    <tr>
        <td>&nbsp;</td><td>[Letter number property (“Nl”) from Unicode]</td>
    </tr>
    <tr>
        <td>&nbsp;</td><td>[Nonspacing Mark property (“Mn”) from Unicode]</td>
    </tr>
    <tr>
        <td>&nbsp;</td><td>[Spacing Combining Mark property (“Mc”) from Unicode]</td>
    </tr>
    <tr>
        <td>&nbsp;</td><td>[Connector Punctuation property (“Pc”) from Unicode]</td>
    </tr>
    <tr>
        <td>&nbsp;</td><td>[Decimal Digit Number property (“Nd”) from Unicode]</td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>_</b></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>$</b></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>UnicodeEscapeSequence</i></td>
    </tr>
</table>
<h2 id="reserved-words"><a class="header" href="#reserved-words">Reserved words</a></h2>
<p><em>ReservedWord</em> includes the following reserved words:</p>
<pre><code class="language-plain">as
do
if
in
is

for
new
not
use
try
var

else
this
true
void
with

await
break
catch
class
const
false
super
throw
while
yield

delete
import
public
return
switch
typeof

extends
finally
package
private

continue
function
internal

interface
protected

implements
</code></pre>
<p><em>ReservedWord</em> includes <em>FutureReservedWord</em>. <em>FutureReservedWord</em> is one of the following:</p>
<pre><code class="language-plain">export
throws
</code></pre>
<p><em>ReservedWord</em> includes <em>ContextKeyword</em>. <em>ContextKeyword</em> is one of the following in certain syntactic contexts:</p>
<pre><code class="language-plain">get
set
xml

each
enum
meta
type

embed
final
proxy
where

native
static

abstract
override

namespace
undefined
</code></pre>
<h2 id="punctuators"><a class="header" href="#punctuators">Punctuators</a></h2>
<p><em>Punctuator</em> includes one of the following:</p>
<pre><code class="language-plain">::  @
.  ..  ...
(  )  [  ]  {  }
:  ;  ,
?  !  =  =&gt;
?.
&lt;  &lt;=
&gt;  &gt;=
==  ===
!=  !==
+  -  *  /  %  **
++  --
&lt;&lt;  &gt;&gt;  &gt;&gt;&gt;
&amp;  ^  |  ~
&amp;&amp;  ^^  ||  ??
</code></pre>
<p><em>Punctuator</em> includes <em>CompoundAssignmentPunctuator</em>. <em>CompoundAssignmentPunctuator</em> is one of the following:</p>
<pre><code class="language-plain">+=  -=  *=  /=  %=  **=
&lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;=  &amp;=  ^=  |=
&amp;&amp;=  ^^=  ||=
??=
</code></pre>
<h2 id="numeric-literal"><a class="header" href="#numeric-literal">Numeric literal</a></h2>
<p><em>NumericLiteral</em> is similiar to <em>NumericLiteral</em> from the ECMA-262 third edition, with support for binary literals:</p>
<pre><code class="language-plain">0b1011
</code></pre>
<h2 id="regular-expression-literal"><a class="header" href="#regular-expression-literal">Regular expression literal</a></h2>
<p><em>RegularExpressionLiteral</em> is similiar to <em>RegularExpressionLiteral</em> from the ECMA-262 third edition, with support for line breaks.</p>
<h2 id="string-literal"><a class="header" href="#string-literal">String literal</a></h2>
<p><em>StringLiteral</em> is similiar to <em>StringLiteral</em> from the ECMA-262 third edition, with additional features:</p>
<ul>
<li>scalar <em>UnicodeEscapeSequence</em> using the <code>\u{...}</code> form;</li>
<li>triple string literals.</li>
</ul>
<p>Triple string literals use either <code>&quot;&quot;&quot;</code> or <code>'''</code> as delimiter and may span multiple lines. The contents of triple string literals are indentation-based, as can be observed in the following code:</p>
<pre><code>const text = &quot;&quot;&quot;
    Have a
    nice day!
    &quot;&quot;&quot;;
assert(text == &quot;Have a\nnice day!&quot;);
</code></pre>
<p>Triple string literals are processed as follows:</p>
<ul>
<li>the first empty line is ignored;</li>
<li>the base indentation of a triple string literal is that of the last string line.</li>
</ul>
<h2 id="comment"><a class="header" href="#comment">Comment</a></h2>
<p><em>Comment</em> is similiar to <em>Comment</em> from the ECMA-262 third edition, with support for nested multi-line comments.</p>
<pre><code>/*
 * /*
 *  *
 *  */
 */
</code></pre>
<h2 id="j4x"><a class="header" href="#j4x">J4X</a></h2>
<p>J4X defines <em>InputElementXMLTag</em> and <em>InputElementXMLContent</em> based on the ECMA-357 second edition.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive types</a></h2>
<p>JetWork considers the following to be primitive types:</p>
<ul>
<li><code>undefined</code> type, or the equivalent <code>void</code></li>
<li>Number types</li>
<li><code>Boolean</code> type</li>
<li><code>String</code> type</li>
<li><code>Char</code> type</li>
<li><code>CharIndex</code> type</li>
</ul>
<h2 id="default-value"><a class="header" href="#default-value">Default value</a></h2>
<p>The default value of a type is determined as follows:</p>
<ul>
<li>If the type is <code>undefined</code>, return <code>undefined</code>.</li>
<li>If the type is <code>Optional</code>, return <code>undefined</code>.</li>
<li>If the type is a number type, return zero.</li>
<li>If the type is <code>Boolean</code>, return false.</li>
<li>If the type is <code>String</code>, return the empty string.</li>
<li>If the type is <code>Char</code>, return U+0000.</li>
<li>If the type is <code>CharIndex</code>, return (<em>empty string</em>, <em>zero</em>).</li>
<li>If the type is a Set <code>enum</code>, return an empty set.</li>
<li>For any other type, return no default value.</li>
</ul>
<h2 id="auto-boxing"><a class="header" href="#auto-boxing">Auto boxing</a></h2>
<p>The language performs auto boxing of primitive types. Primitive types are represented in a memory efficient way wherever available, including within an <code>Array</code>.</p>
<p>Primitive types are boxed without duplicating identity:</p>
<pre><code>var x: Object = 10
var y: Object = 10

// true
x == y
</code></pre>
<h2 id="any-type"><a class="header" href="#any-type">Any type</a></h2>
<p>The <code>*</code> type contains values from all other types.</p>
<h2 id="void-type"><a class="header" href="#void-type">Void type</a></h2>
<p>The <code>void</code> type consists of the <code>undefined</code> constant. The <code>void</code> type may alternatively be expressed as <code>undefined</code>.</p>
<h2 id="number-types"><a class="header" href="#number-types">Number types</a></h2>
<p><em>IEEE 754 floating point</em>:</p>
<ul>
<li><code>Number</code> — Double-precision floating point</li>
<li><code>Single</code> — Single-precision floating point</li>
</ul>
<p><em>Signed integer</em>:</p>
<ul>
<li><code>BigInt</code> — Arbitrary range integer</li>
<li><code>Long</code> — Ranges from -2<sup>64 - 1</sup> to 2<sup>64 - 1</sup> - 1 (64-bit)</li>
<li><code>Int</code> — Ranges from -2<sup>32 - 1</sup> to 2<sup>32 - 1</sup> - 1 (32-bit)</li>
<li><code>Short</code> — Ranges from -2<sup>16 - 1</sup> to 2<sup>16 - 1</sup> - 1 (16-bit)</li>
<li><code>Byte</code> — Ranges from -2<sup>8 - 1</sup> to 2<sup>8 - 1</sup> - 1 (8-bit)</li>
</ul>
<p><em>Unsigned integer</em>:</p>
<ul>
<li><code>UnsignedLong</code> — Ranges from 0 to 2<sup>64</sup> - 1 (64-bit)</li>
<li><code>UnsignedInt</code> — Ranges from 0 to 2<sup>32</sup> - 1 (32-bit)</li>
<li><code>UnsignedShort</code> — Ranges from 0 to 2<sup>16</sup> - 1 (16-bit)</li>
<li><code>UnsignedByte</code> — Ranges from 0 to 2<sup>8</sup> - 1 (8-bit)</li>
</ul>
<h2 id="boolean-type"><a class="header" href="#boolean-type">Boolean type</a></h2>
<p>The <code>Boolean</code> type consists of the values <code>false</code> and <code>true</code>.</p>
<h2 id="string-type"><a class="header" href="#string-type">String type</a></h2>
<p>The <code>String</code> type consists of a sequence of Unicode Scalar Values whose encoding is implementation-defined.</p>
<h2 id="char-type"><a class="header" href="#char-type">Char type</a></h2>
<p>The <code>Char</code> type is a Unicode Scalar Value.</p>
<h2 id="charindex-type"><a class="header" href="#charindex-type">CharIndex type</a></h2>
<p>The <code>CharIndex</code> type is a group (<em>string</em>, <em>index</em>) where <em>string</em> is a <code>String</code> and <em>index</em> is an <code>UnsignedInt</code> identifying a zero based index into <em>string</em>.</p>
<h2 id="function-types"><a class="header" href="#function-types">Function types</a></h2>
<p>Function types consist of zero or more parameters and a return type annotation. Function types appear in the forms:</p>
<pre><code>(a: T) =&gt; E
(a?: T) =&gt; E
(...a: [T]) =&gt; E
</code></pre>
<ul>
<li>Function types inherit from the <code>Function</code> class.</li>
<li>Function types are final classes.</li>
<li>Each parameter is either a required, optional or rest parameter.</li>
<li>The allowed parameter list is a list of zero or more required parameters followed by zero or more optional parameters followed by an optional rest parameter.</li>
<li>The rest parameter must appear at most once.</li>
<li>The rest parameter must be of type <code>Array</code>.</li>
</ul>
<h2 id="tuple-types"><a class="header" href="#tuple-types">Tuple types</a></h2>
<p>Tuple types are in the form <code>[T1, T2, ...TN]</code> and consist of a sequence of two or more element types.</p>
<ul>
<li>Tuple types inherit from the <code>Object</code> class.</li>
<li>Tuple types are final classes.</li>
</ul>
<h2 id="optional-type"><a class="header" href="#optional-type">Optional type</a></h2>
<p>The <code>Optional.&lt;T&gt;</code> type is an union of <code>undefined</code> and <code>T</code>. <code>Optional.&lt;T&gt;</code> may be expressed as <code>Optional.&lt;T&gt;</code>, <code>T?</code>, or <code>?T</code>.</p>
<p>It is not allowed for <code>T</code> to be of the <code>Optional</code> type. When a type expression attempts to wrap an <code>Optional</code> type into another <code>Optional</code> type, it results in the same former <code>Optional</code> type.</p>
<pre><code>// Equivalent to
// type O = Optional.&lt;T&gt;;
type O = Optional.&lt;Optional.&lt;T&gt;&gt;;
</code></pre>
<ul>
<li>The <code>Optional.&lt;T&gt;</code> type is a final class type.</li>
<li>The <code>Optional.&lt;T&gt;</code> type inherits from <code>Object</code>.</li>
</ul>
<h2 id="array-type"><a class="header" href="#array-type">Array type</a></h2>
<p>The <code>Array.&lt;T&gt;</code> type is a growable collection of <code>T</code> values. <code>Array</code> may be expressed as <code>Array.&lt;T&gt;</code> or <code>[T]</code>.</p>
<h2 id="object-type"><a class="header" href="#object-type">Object type</a></h2>
<p>The <code>Object</code> type is the super type of all other classes and all enums.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-conversions"><a class="header" href="#type-conversions">Type conversions</a></h1>
<h2 id="implicit-constant-conversions"><a class="header" href="#implicit-constant-conversions">Implicit constant conversions</a></h2>
<p>The language performs implicit compile-time type conversions from a constant to a constant of another type. They are described by the following table:</p>
<div class="table-wrapper"><table><thead><tr><th>Relationship</th><th>Description</th></tr></thead><tbody>
<tr><td><code>undefined</code> to <code>*</code>, <code>Optional</code>, Set <code>enum</code></td><td>For Set <code>enum</code>, results into an empty set. For other types, results into <code>undefined</code>.</td></tr>
<tr><td><code>N</code> constant to <code>*</code>, <code>Object</code></td><td>Results into a <code>N</code> number constant of a covariant type.</td></tr>
<tr><td><code>NF1</code> constant to <code>NF2</code> or <code>Optional.&lt;NF2&gt;</code></td><td>Results into a floating point constant with the same numeric value, where <code>NF2</code> is a floating point type whose range is wider than that of <code>NF1</code>.</td></tr>
<tr><td><code>NI1</code> constant to <code>NI2</code> or <code>Optional.&lt;NI2&gt;</code></td><td>Results into an integer constant with the same numeric value, where <code>NI2</code> is a integer type whose range is wider than that of <code>NI1</code>.</td></tr>
<tr><td><code>NI</code> constant to <code>Number</code> or <code>Optional.&lt;Number&gt;</code></td><td>Results into a number constant with the same numeric value, where <code>NI</code> is one of { <code>Byte</code>, <code>UnsignedByte</code>, <code>Short</code>, <code>UnsignedShort</code>, <code>Int</code>, <code>UnsignedInt</code> }.</td></tr>
<tr><td><code>NaN</code> constant to <code>NI</code> or <code>Optional.&lt;NI&gt;</code></td><td>Results into a zero (0) constant where <code>NI</code> is an integer type.</td></tr>
<tr><td><code>-Infinity</code> constant to <code>NI</code> or <code>Optional.&lt;NI&gt;</code></td><td>Results into the minimum integer constant where <code>NI</code> is an integer type but not <code>BigInt</code>.</td></tr>
<tr><td><code>+Infinity</code> constant to <code>NI</code> or <code>Optional.&lt;NI&gt;</code></td><td>Results into the maximum integer constant where <code>NI</code> is an integer type but not <code>BigInt</code>.</td></tr>
</tbody></table>
</div>
<h2 id="implicit-conversions"><a class="header" href="#implicit-conversions">Implicit conversions</a></h2>
<p>An implicit conversion is followed by an attempt of an implicit constant conversion. Implicit conversions are described by the following table:</p>
<div class="table-wrapper"><table><thead><tr><th>Relationship</th><th>Description</th></tr></thead><tbody>
<tr><td>From <code>*</code></td><td>Converts to type from the <code>*</code> type or a conversion failure if the conversion fails at runtime.</td></tr>
<tr><td>To <code>*</code></td><td>Converts to the <code>*</code> type.</td></tr>
<tr><td><code>N1</code> to <code>N2</code></td><td>Results into a number constant with the same numeric value, where <code>N2</code> is a number type whose range is wider than that of <code>N1</code>.</td></tr>
<tr><td>To covariant type</td><td>Results into a reference of a covariant type.</td></tr>
<tr><td>From <code>T</code> to <code>Optional.&lt;T&gt;</code></td><td>Results into a <code>Optional.&lt;T&gt;</code> value containing a <code>T</code> value.</td></tr>
</tbody></table>
</div>
<h2 id="explicit-conversions"><a class="header" href="#explicit-conversions">Explicit conversions</a></h2>
<p>An explicit conversion is followed by an attempt of an implicit conversion. Explicit conversions are described by the following table:</p>
<div class="table-wrapper"><table><thead><tr><th>Relationship</th><th>Description</th></tr></thead><tbody>
<tr><td>To <code>T</code> through <code>proxy::to</code></td><td>Converts to type <code>T</code> by invoking the <code>to</code> proxy if present.</td></tr>
<tr><td>To <code>T</code> through <code>proxy::toOptional</code></td><td>Converts to type <code>T</code> by invoking the <code>toOptional</code> proxy if present. It is a conversion failure if <code>toOptional</code> returns undefined.</td></tr>
<tr><td>To contravariant type</td><td>Results into a reference of a contravariant type or a conversion failure if destination is incompatible.</td></tr>
<tr><td><code>Array</code> to contravariant <code>Array</code></td><td>Constructs a new array filtering out covariant elements.</td></tr>
<tr><td><code>Array</code> to covariant <code>Array</code></td><td>Constructs a new array of a covariant type.</td></tr>
<tr><td>Between number types</td><td>Converts from a number type to another number type. The result is implementation-defined.</td></tr>
<tr><td>From <code>String</code> to <code>enum</code></td><td>Converts to <code>enum</code> by identifying a member by its string component. It is a failure if the member is not found.</td></tr>
<tr><td>From number to <code>enum</code></td><td>For a non Set <code>enum</code>, converts to the <code>enum</code> by identifying a member by its number component. It is a failure if the member is not found. For a Set <code>enum</code>, converts to the <code>enum</code> by filtering out unrecognized bits.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="visibility"><a class="header" href="#visibility">Visibility</a></h1>
<p>A visibility is either <code>public</code>, <code>private</code>, <code>protected</code> or <code>internal</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Visibility</th><th>Description</th></tr></thead><tbody>
<tr><td><code>public</code></td><td>The <code>public</code> visibility indicates that a property is accessible from anywhere.</td></tr>
<tr><td><code>private</code></td><td>The <code>private</code> visibility indicates that a property is accessible from within a class block.</td></tr>
<tr><td><code>protected</code></td><td>The <code>protected</code> visibility indicates that a property is accessible from the block of a class and any subclasses.</td></tr>
<tr><td><code>internal</code></td><td>The <code>internal</code> visibility indicates that a property is accessible from the enclosing package, excluding subpackages.</td></tr>
</tbody></table>
</div>
<ul>
<li>When a property is not <code>public</code>, it is not allowed for such property to be found at runtime.</li>
<li>When a property is not <code>public</code>, it is not contained in the runtime type information.</li>
</ul>
<h2 id="propertyisvisible"><a class="header" href="#propertyisvisible">PropertyIsVisible()</a></h2>
<p>The internal <em>PropertyIsVisible</em>(<em>prop</em>, <em>scope</em>) function takes the following steps:</p>
<ol>
<li>Let <em>v</em> be <em>prop</em>[[<em>Visibility</em>]]</li>
<li>If <em>v</em> is <code>public</code>, return true.</li>
<li>If <em>v</em> is <code>internal</code>
<ol>
<li>Let <em>p</em> be undefined.</li>
<li>Let <em>p1</em> be <em>prop</em>[[<em>ParentDefinition</em>]]</li>
<li>While <em>p1</em> is defined
<ol>
<li>If <em>p1</em> is a <code>package</code>
<ol>
<li>Assign <em>p</em> = <em>p1</em></li>
<li>Exit loop</li>
</ol>
</li>
<li>Assign <em>p1</em> = <em>p1</em>[[<em>ParentDefinition</em>]]</li>
</ol>
</li>
<li>If <em>p</em> is undefined
<ol>
<li>Return true.</li>
</ol>
</li>
<li>While <em>scope</em> is defined
<ol>
<li>If <em>scope</em> is a <code>package</code> scope and <em>scope</em>[[<em>Package</em>]] equals <em>p</em>
<ol>
<li>Return true.</li>
</ol>
</li>
<li>Assign <em>scope</em> = <em>scope</em>[[<em>ParentScope</em>]]</li>
</ol>
</li>
<li>Return false.</li>
</ol>
</li>
<li>If <em>v</em> is <code>private</code>
<ol>
<li>Let <em>t</em> be undefined.</li>
<li>Let <em>p</em> be <em>prop</em>[[<em>ParentDefinition</em>]]</li>
<li>While <em>p</em> is defined
<ol>
<li>If <em>p</em> is a <code>class</code> or <code>enum</code>
<ol>
<li>Assign <em>t</em> = <em>p</em></li>
<li>Exit loop</li>
</ol>
</li>
<li>Assign <em>p</em> = <em>p</em>[[<em>ParentDefinition</em>]]</li>
</ol>
</li>
<li>If <em>t</em> is undefined
<ol>
<li>Return false</li>
</ol>
</li>
<li>While <em>scope</em> is defined
<ol>
<li>If <em>scope</em> is a <code>class</code> scope or <code>enum</code> scope and <em>scope</em>[[<em>Class</em>]] equals <em>t</em>
<ol>
<li>Return true.</li>
</ol>
</li>
<li>Assign <em>scope</em> = <em>scope</em>[[<em>ParentScope</em>]]</li>
</ol>
</li>
<li>Return false.</li>
</ol>
</li>
<li>If <em>v</em> is <code>protected</code>
<ol>
<li>Let <em>t</em> be undefined.</li>
<li>Let <em>p</em> be <em>prop</em>[[<em>ParentDefinition</em>]]</li>
<li>While <em>p</em> is defined
<ol>
<li>If <em>p</em> is a <code>class</code> or <code>enum</code>
<ol>
<li>Assign <em>t</em> = <em>p</em></li>
<li>Exit loop</li>
</ol>
</li>
<li>Assign <em>p</em> = <em>p</em>[[<em>ParentDefinition</em>]]</li>
</ol>
</li>
<li>If <em>t</em> is undefined
<ol>
<li>Return false</li>
</ol>
</li>
<li>While <em>scope</em> is defined
<ol>
<li>If <em>scope</em> is a <code>class</code> scope or <code>enum</code> scope
<ol>
<li>Let <em>scopeClass</em> be <em>scope</em>[[<em>Class</em>]]</li>
<li>If <em>scopeClass</em> equals <em>t</em> or <em>scopeClass</em> is a subtype of <em>t</em>
<ol>
<li>Return true.</li>
</ol>
</li>
</ol>
</li>
<li>Assign <em>scope</em> = <em>scope</em>[[<em>ParentScope</em>]]</li>
</ol>
</li>
<li>Return false.</li>
</ol>
</li>
<li>Return false.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packages"><a class="header" href="#packages">Packages</a></h1>
<p>Packages as denoted by the <code>package</code> keyword are used to organize properties and classes. For an user to refer to a package's property it must be imported beforehand through an <code>import</code> directive or an <code>use</code> definition.</p>
<pre><code>// Top-level package
package {
    public const globalProperty: Number = Infinity;
}

// &quot;org.x.y&quot; package
package org.x.y {
    public const xyProperty: Number = 10;
}

// Infinity
trace(globalProperty);

// 10
import org.x.y.*;
trace(xyProperty);
trace(org.x.y.xyProperty);
</code></pre>
<p>The fully package qualified name of an imported package's property shadows any variable name in scope:</p>
<pre><code>public class Org {
    public const x: OrgX = new OrgX;
}
public class OrgX {
    public const y: OrgY = new OrgY;
}
public class OrgY {
    public const xyProperty: Number = Infinity;
}

import org.x.y.*;

const org = new Org;

// [object Org]
trace(org);

// 10 (not Infinity)
trace(org.x.y.xyProperty);
</code></pre>
<p>Packages consist of the following internal properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Internal property</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Name</em>]]</td><td>The unqualified name of the package.</td></tr>
<tr><td>[[<em>ParentDefinition</em>]]</td><td>Optional parent package.</td></tr>
<tr><td>[[<em>Properties</em>]]</td><td>Properties of the package as a dictionary from string to symbol.</td></tr>
<tr><td>[[<em>WildcardUses</em>]]</td><td>The wildcard uses of the package.</td></tr>
<tr><td>[[<em>Subpackages</em>]]</td><td>The subpackages of the package.</td></tr>
</tbody></table>
</div>
<h2 id="wildcard-uses"><a class="header" href="#wildcard-uses">Wildcard uses</a></h2>
<p>Directives of the form <code>public use q.*;</code> contribute a wildcard use to a package. Wildcard uses are used in name resolution to resolve to names from another package.</p>
<pre><code>package org.alias.core {
    public use org.origin.core.*;
}
</code></pre>
<h2 id="subpackages"><a class="header" href="#subpackages">Subpackages</a></h2>
<p>A package may have zero or more subpackages. The top-level package contains the topmost packages as subpackages.</p>
<pre><code>// Subpackage of top-level package
package q1 {}
// Subpackage of &quot;q1&quot;
package q1.q2 {}
// Subpackage of &quot;q1.q2&quot;
package q1.q2.qN {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>A variable is a fixed slot storing a value.</p>
<pre><code>var x: Number;
const y: Number;
</code></pre>
<p>A variable consists of the following internal properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Internal property</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Name</em>]]</td><td>The unqualified name of the variable.</td></tr>
<tr><td>[[<em>Type</em>]]</td><td>The type of the variable.</td></tr>
<tr><td>[[<em>Visibility</em>]]</td><td>The <a href="visibility.html">visibility</a> of the variable.</td></tr>
<tr><td>[[<em>ParentDefinition</em>]]</td><td>The parent definition of the variable.</td></tr>
<tr><td>[[<em>ReadOnly</em>]]</td><td>Indicates whether the variable is read-only or not.</td></tr>
<tr><td>[[<em>IsJXMLVariable</em>]]</td><td>Indicates whether it is a JXML instance variable belonging to a JXML file.</td></tr>
<tr><td>[[<em>ConstantInitializer</em>]]</td><td>Constant initializer of the variable as a constant value.</td></tr>
<tr><td>[[<em>PlainMetadata</em>]]</td><td>Plain meta-data attached to the variable.</td></tr>
</tbody></table>
</div>
<h2 id="read-only-variables"><a class="header" href="#read-only-variables">Read-only variables</a></h2>
<p>A variable may be read-only by using the <code>const</code> keyword instead of the <code>var</code> keyword when defining it.</p>
<h2 id="initializer"><a class="header" href="#initializer">Initializer</a></h2>
<p>Variables are lazily initialized with the exception of variables whose static type has a <em>default</em> value, such as a <a href="types.html#primitive-types">primitive type</a> or the <code>Optional</code> type.</p>
<ul>
<li>It is a <code>ReferenceError</code> if the value of a variable is accessed before initialized and the static type of that variable includes no default value.</li>
</ul>
<pre><code>public class C {
    public const x: Number
    public const y: RegExp
    public function C() {
        x // 0
        y // ReferenceError
    }
}
</code></pre>
<ul>
<li>It is a <code>VerifyError</code> if a constant variable is assigned more than once.</li>
<li>A constant variable that is not an instance variable must contain an initializer.</li>
<li>A constant variable that is not an instance variable must not be assigned by an assignment expression.</li>
<li>A constant variable that is an instance variable may be assigned in the constructor body.</li>
<li>A constant variable that is an instance variable may not be assigned outside the constructor body.</li>
</ul>
<p><em>Constant initializer</em>: A variable may consist of a constant initializer. A constant initializer consists of a constant expression.</p>
<h2 id="meta-data"><a class="header" href="#meta-data">Meta data</a></h2>
<p>A variable may contain zero or more plain meta-data.</p>
<pre><code>[[N1(n2)]]
const x: T;
</code></pre>
<h2 id="jxml-variables"><a class="header" href="#jxml-variables">JXML variables</a></h2>
<p>A JXML variable is an instance variable belonging to a JXML file.</p>
<ul>
<li>Assigning value to a JXML variable causes the following post assigment to the instance object:</li>
</ul>
<pre><code>instance.jxmlStatus = &quot;outdated&quot;;
</code></pre>
<h2 id="optional-variables"><a class="header" href="#optional-variables">Optional variables</a></h2>
<p>Optional variables do not need to be specified when using an object initializer:</p>
<pre><code>[Literal]
public class C {
    public const x: Optional.&lt;Number&gt;;
}
const o: C = {};
</code></pre>
<p>A variable is <em>optional</em> when the variable's static type is the <code>Optional</code> type.</p>
<h2 id="parent-definition"><a class="header" href="#parent-definition">Parent definition</a></h2>
<p>When the parent definition of a variable is a package, the variable has a fully package qualified name.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="virtual-properties"><a class="header" href="#virtual-properties">Virtual properties</a></h1>
<p>A virtual property is an accessor that may be used as a variable.</p>
<ul>
<li>A virtual property is read-only if it has only a getter.</li>
<li>A virtual property is write-only if it has only a setter.</li>
<li>Getter and setter are functions that belong to the virtual property.</li>
</ul>
<pre><code>function get x(): T (v);
function set x(v: T): void {}
</code></pre>
<p>Virtual properties consist of the following internal properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Internal property</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Name</em>]]</td><td>The unqualified name of the virtual property.</td></tr>
<tr><td>[[<em>Type</em>]]</td><td>The type of the virtual property, inferred from the getter or setter.</td></tr>
<tr><td>[[<em>Visibility</em>]]</td><td>The <a href="visibility.html">visibility</a> of the virtual property.</td></tr>
<tr><td>[[<em>ParentDefinition</em>]]</td><td>The parent definition of the virtual property.</td></tr>
<tr><td>[[<em>ReadOnly</em>]]</td><td>Indicates whether the virtual property is read-only or not.</td></tr>
<tr><td>[[<em>WriteOnly</em>]]</td><td>Indicates whether the virtual property is write-only or not.</td></tr>
<tr><td>[[<em>PlainMetadata</em>]]</td><td>Plain meta-data attached to the virtual property.</td></tr>
</tbody></table>
</div>
<h2 id="parent-definition-1"><a class="header" href="#parent-definition-1">Parent definition</a></h2>
<p>When the parent definition of a virtual property is a package, the virtual property has a fully package qualified name.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>A function represents an invokable symbol that takes parameters and returns a value.</p>
<p>Functions consist of the following internal properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Internal property</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Name</em>]]</td><td>The unqualified name of the function.</td></tr>
<tr><td>[[<em>Signature</em>]]</td><td>A static function type describing the function signature.</td></tr>
<tr><td>[[<em>Visibility</em>]]</td><td>The <a href="visibility.html">visibility</a> of the function.</td></tr>
<tr><td>[[<em>ParentDefinition</em>]]</td><td>The parent definition of the function.</td></tr>
<tr><td>[[<em>TypeParameters</em>]]</td><td>The type parameter sequence of the function if it is generic.</td></tr>
<tr><td>[[<em>IsGenerator</em>]]</td><td>Indicates whether the function is a generator.</td></tr>
<tr><td>[[<em>IsAsync</em>]]</td><td>Indicates whether the function is asynchronous.</td></tr>
<tr><td>[[<em>IsNative</em>]]</td><td>Indicates whether the function is native.</td></tr>
<tr><td>[[<em>IsOptionalInterfaceMethod</em>]]</td><td>Indicates whether the function is an optional interface method.</td></tr>
<tr><td>[[<em>IsOverriding</em>]]</td><td>Indicates whether the function is overriding another function.</td></tr>
<tr><td>[[<em>IsFinal</em>]]</td><td>Indicates whether a method is final.</td></tr>
<tr><td>[[<em>IsAbstract</em>]]</td><td>Indicates whether a method is abstract.</td></tr>
<tr><td>[[<em>OfVirtualProperty</em>]]</td><td>Indicates the virtual property to which a getter or setter belongs.</td></tr>
<tr><td>[[<em>PlainMetadata</em>]]</td><td>Plain meta-data attached to the function.</td></tr>
</tbody></table>
</div>
<h2 id="parent-definition-2"><a class="header" href="#parent-definition-2">Parent definition</a></h2>
<p>When the parent definition of a function is a package, the function has a fully package qualified name.</p>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>A function may be <a href="generics.html">generic</a>:</p>
<pre><code>function f.&lt;T&gt;(): void {}
</code></pre>
<h2 id="generators"><a class="header" href="#generators">Generators</a></h2>
<p>A function is a generator if it contains the <code>yield</code> operator.</p>
<ul>
<li>Non asynchronous generators return <code>Generator.&lt;T&gt;</code>.</li>
<li>Asynchronous generators return <code>Generator.&lt;Promise.&lt;T&gt;&gt;</code>.</li>
</ul>
<h2 id="asynchronous-functions"><a class="header" href="#asynchronous-functions">Asynchronous functions</a></h2>
<p>A function is asynchronous if it contains the <code>await</code> operator.</p>
<ul>
<li>Non generator asynchronous functions return <code>Promise.&lt;T&gt;</code>.</li>
<li>Asynchronous generators return <code>Generator.&lt;Promise.&lt;T&gt;&gt;</code>.</li>
</ul>
<h2 id="native-functions"><a class="header" href="#native-functions">Native functions</a></h2>
<p>A function is native if it contains the <code>native</code> attribute.</p>
<pre><code>native function f(): void;
</code></pre>
<h2 id="meta-data-1"><a class="header" href="#meta-data-1">Meta data</a></h2>
<p>A function may contain zero or more plain meta-data.</p>
<pre><code>[[N1(n2)]]
function f1(): void {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instance-methods"><a class="header" href="#instance-methods">Instance methods</a></h1>
<p>An instance method is a non static function directly enclosed by a <code>class</code>, <code>enum</code> or <code>interface</code> block.</p>
<h2 id="abstract-methods"><a class="header" href="#abstract-methods">Abstract methods</a></h2>
<p>An abstract method contains the <code>abstract</code> attribute.</p>
<ul>
<li>Abstract methods must not contain a body.</li>
<li>Abstract methods must be overriden by subclasses of the enclosing class.</li>
</ul>
<h2 id="final-methods"><a class="header" href="#final-methods">Final methods</a></h2>
<p>A final method contains the <code>final</code> attribute.</p>
<ul>
<li>Final methods must not be overriden by subclasses of the enclosing class.</li>
</ul>
<h2 id="overriding"><a class="header" href="#overriding">Overriding</a></h2>
<p>An overriding method contains the <code>override</code> attribute.</p>
<pre><code>class C1 {
    function f(): void {}
}
class C2 extends C1 {
    override function f(): void {}
}
</code></pre>
<h3 id="overriding-signature"><a class="header" href="#overriding-signature">Overriding signature</a></h3>
<p>It is a verify error if the overriding signature is not compatible with the super class's method signature.</p>
<ul>
<li>The overriding signature is compatible with the super signature if either:
<ul>
<li>it is equals the super signature, or</li>
<li>it introduces optional parameters and/or a rest parameter to the super signature.</li>
</ul>
</li>
</ul>
<pre><code>class C1 {
    function f(): void {}
}
class C2 extends C1 {
    override function f(a: Number = 10): void {}
}
</code></pre>
<h3 id="overriding-symbol"><a class="header" href="#overriding-symbol">Overriding symbol</a></h3>
<p>It is allowed for an overriding method to override:</p>
<ul>
<li>a regular method;</li>
<li>a getter;</li>
<li>a setter.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interface-methods"><a class="header" href="#interface-methods">Interface methods</a></h1>
<p>An interface method is an instance method belonging to an interface.</p>
<h2 id="optional-interface-method"><a class="header" href="#optional-interface-method">Optional interface method</a></h2>
<p>A function that is an interface method may be optional.</p>
<pre><code>interface I {
    function f(): void {}
}
</code></pre>
<h2 id="interface-method-forms"><a class="header" href="#interface-method-forms">Interface method forms</a></h2>
<p>An interface method is allowed to be:</p>
<ul>
<li>a regular method;</li>
<li>a getter;</li>
<li>a setter.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getters-and-setters"><a class="header" href="#getters-and-setters">Getters and setters</a></h1>
<p>A function that belongs to a virtual property is either a getter or setter.</p>
<pre><code>function get x(): T (v);
function set x(v: T): void {}
</code></pre>
<ul>
<li>Getters and setters must not be asynchronous.</li>
<li>Getters and setters must not be generators.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructors"><a class="header" href="#constructors">Constructors</a></h1>
<p>A constructor is a function whose name matches the enclosing class's name.</p>
<ul>
<li>A constructor must not be generic.</li>
<li>A constructor must not be asynchronous.</li>
<li>A constructor must not be a generator.</li>
<li>It is a verify error if the constructor has no <code>super();</code> statement and the constructor of the parent class has a non-empty parameter list.</li>
<li>A constructor is allowed to perform assignments to constant instance variables.</li>
<li>A constructor is allowed to contain a single <code>super();</code> statement.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proxies"><a class="header" href="#proxies">Proxies</a></h1>
<p>A proxy is a function containing the <code>proxy</code> attribute, enclosed by a <code>class</code> or <code>enum</code> block. The name of a proxy must be one of the several proxy names listed in this section.</p>
<ul>
<li><a href="functions/proxies.html#positive">positive</a></li>
<li><a href="functions/proxies.html#negate">negate</a></li>
<li><a href="functions/proxies.html#bitwisenot">bitwiseNot</a></li>
<li><a href="functions/proxies.html#add">add</a></li>
<li><a href="functions/proxies.html#subtract">subtract</a></li>
<li><a href="functions/proxies.html#multiply">multiply</a></li>
<li><a href="functions/proxies.html#divide">divide</a></li>
<li><a href="functions/proxies.html#remainder">remainder</a></li>
<li><a href="functions/proxies.html#power">power</a></li>
<li><a href="functions/proxies.html#bitwiseand">bitwiseAnd</a></li>
<li><a href="functions/proxies.html#bitwisexor">bitwiseXor</a></li>
<li><a href="functions/proxies.html#bitwiseor">bitwiseOr</a></li>
<li><a href="functions/proxies.html#shiftleft">shiftLeft</a></li>
<li><a href="functions/proxies.html#shiftright">shiftRight</a></li>
<li><a href="functions/proxies.html#shiftrightunsigned">shiftRightUnsigned</a></li>
<li><a href="functions/proxies.html#to">to</a></li>
<li><a href="functions/proxies.html#tooptional">toOptional</a></li>
<li><a href="functions/proxies.html#getproperty">getProperty</a></li>
<li><a href="functions/proxies.html#setproperty">setProperty</a></li>
<li><a href="functions/proxies.html#deleteproperty">deleteProperty</a></li>
<li><a href="functions/proxies.html#has">has</a></li>
</ul>
<h2 id="positive"><a class="header" href="#positive">positive</a></h2>
<pre><code>class C {
    proxy function positive(): T {}
}
</code></pre>
<h2 id="negate"><a class="header" href="#negate">negate</a></h2>
<pre><code>class C {
    proxy function negate(): T {}
}
</code></pre>
<h2 id="bitwisenot"><a class="header" href="#bitwisenot">bitwiseNot</a></h2>
<pre><code>class C {
    proxy function bitwiseNot(): T {}
}
</code></pre>
<h2 id="add"><a class="header" href="#add">add</a></h2>
<pre><code>class C {
    proxy function add(right: C): T {}
}
</code></pre>
<h2 id="subtract"><a class="header" href="#subtract">subtract</a></h2>
<pre><code>class C {
    proxy function subtract(right: C): T {}
}
</code></pre>
<h2 id="multiply"><a class="header" href="#multiply">multiply</a></h2>
<pre><code>class C {
    proxy function multiply(right: C): T {}
}
</code></pre>
<h2 id="divide"><a class="header" href="#divide">divide</a></h2>
<pre><code>class C {
    proxy function divide(right: C): T {}
}
</code></pre>
<h2 id="remainder"><a class="header" href="#remainder">remainder</a></h2>
<pre><code>class C {
    proxy function remainder(right: C): T {}
}
</code></pre>
<h2 id="power"><a class="header" href="#power">power</a></h2>
<pre><code>class C {
    proxy function power(right: C): T {}
}
</code></pre>
<h2 id="bitwiseand"><a class="header" href="#bitwiseand">bitwiseAnd</a></h2>
<pre><code>class C {
    proxy function bitwiseAnd(right: C): T {}
}
</code></pre>
<h2 id="bitwisexor"><a class="header" href="#bitwisexor">bitwiseXor</a></h2>
<pre><code>class C {
    proxy function bitwiseXor(right: C): T {}
}
</code></pre>
<h2 id="bitwiseor"><a class="header" href="#bitwiseor">bitwiseOr</a></h2>
<pre><code>class C {
    proxy function bitwiseOr(right: C): T {}
}
</code></pre>
<h2 id="shiftleft"><a class="header" href="#shiftleft">shiftLeft</a></h2>
<pre><code>class C {
    proxy function shiftLeft(right: C): T {}
}
</code></pre>
<h2 id="shiftright"><a class="header" href="#shiftright">shiftRight</a></h2>
<pre><code>class C {
    proxy function shiftRight(right: C): T {}
}
</code></pre>
<h2 id="shiftrightunsigned"><a class="header" href="#shiftrightunsigned">shiftRightUnsigned</a></h2>
<pre><code>class C {
    proxy function shiftRightUnsigned(right: C): T {}
}
</code></pre>
<h2 id="to"><a class="header" href="#to">to</a></h2>
<ul>
<li>The <code>to</code> proxy adds explicit conversion from the enclosing class to the type it returns.</li>
<li>The <code>to</code> proxy may be defined multiple times.</li>
</ul>
<pre><code>class C {
    proxy function to(): T {}
}
</code></pre>
<h2 id="tooptional"><a class="header" href="#tooptional">toOptional</a></h2>
<ul>
<li>The <code>toOptional</code> proxy adds explicit conversion from the enclosing class to the type <code>T</code> it returns. Such proxy is used for an optional conversion using the <code>as</code> operator.</li>
<li>The <code>toOptional</code> proxy may be defined multiple times.</li>
</ul>
<pre><code>class C {
    proxy function toOptional(): T? {}
}
</code></pre>
<h2 id="getproperty"><a class="header" href="#getproperty">getProperty</a></h2>
<pre><code>class C {
    proxy function getProperty(k: K): T {}
}
</code></pre>
<h2 id="setproperty"><a class="header" href="#setproperty">setProperty</a></h2>
<pre><code>class C {
    proxy function setProperty(k: K, v: V): void {}
}
</code></pre>
<h2 id="deleteproperty"><a class="header" href="#deleteproperty">deleteProperty</a></h2>
<pre><code>class C {
    proxy function deleteProperty(k: K): Boolean {}
}
</code></pre>
<h2 id="has"><a class="header" href="#has">has</a></h2>
<pre><code>class C {
    proxy function has(v: T): Boolean {}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-1"><a class="header" href="#generics-1">Generics</a></h1>
<p>The language supports generic types and functions that consist of a sequence of type parameters. </p>
<pre><code>class C.&lt;T&gt; {}
function f.&lt;T&gt;(): void {}
</code></pre>
<h2 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h2>
<p>The language uses polymorphism for generic types and functions, except for the <code>Array</code> class applied with a <a href="types.html#primitive-types">primitive type</a>. With polymorphism, type parameters are substituted by the <code>*</code> type and additional compile-time type checking occurs when using the generic type or function.</p>
<h2 id="constraints"><a class="header" href="#constraints">Constraints</a></h2>
<p>The language does not support constraints on type parameters in the present, such as those present in the Java language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meta-data-2"><a class="header" href="#meta-data-2">Meta-data</a></h1>
<p>The language supports directive attributes using brackets notation called <em>meta-data</em>. The language recognizes <em>reserved</em> meta-data, <em>decorator</em> meta-data, and <em>plain</em> meta-data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reserved-meta-data"><a class="header" href="#reserved-meta-data">Reserved meta-data</a></h1>
<p>Reserved meta-data are meta-data that cannot be overriden by user decorators. This section enumerates all reserved meta-data.</p>
<ul>
<li><a href="metadata/reserved-metadata.html#jxml">JXML</a></li>
<li><a href="metadata/reserved-metadata.html#literal">Literal</a></li>
<li><a href="metadata/reserved-metadata.html#number">Number</a></li>
<li><a href="metadata/reserved-metadata.html#set">Set</a></li>
<li><a href="metadata/reserved-metadata.html#test">Test</a></li>
</ul>
<h2 id="jxml"><a class="header" href="#jxml">JXML</a></h2>
<p>The <code>JXML</code> meta-data is reserved at the <code>class</code> definition. It is used for indicating supported vector and color classes in a base class that implements <code>JXML</code>.</p>
<h2 id="literal"><a class="header" href="#literal">Literal</a></h2>
<p>The <code>Literal</code> meta-data is reserved at the <code>class</code> definition. It is used for indicating that the class can be initialized through an object initializer.</p>
<h2 id="number"><a class="header" href="#number">Number</a></h2>
<p>The <code>Number</code> meta-data is reserved at the <code>enum</code> definition. It is used for selecting the number type to use for representing instances of the <code>enum</code>.</p>
<h2 id="set"><a class="header" href="#set">Set</a></h2>
<p>The <code>Set</code> meta-data is reserved at the <code>enum</code> definition. It is used for indicating that the <code>enum</code> is a set enumeration.</p>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<p>The <code>Test</code> meta-data is reserved at the <code>function</code> definition. It is used for indicating that a function is a test unit.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decorator-meta-data"><a class="header" href="#decorator-meta-data">Decorator meta-data</a></h1>
<p>A decorator meta-data invokes an user function, either at class instance initialization, at type initialization, or instance method initialization.</p>
<p>Decorator meta-data may only be applied to instance variables, instance methods, and type definitions.</p>
<h2 id="instance-variables"><a class="header" href="#instance-variables">Instance variables</a></h2>
<p>A decorator meta-data applied to an instance variable must contain a signature <code>(instance: C, name: String, type: Class) =&gt; void</code>, where <code>C</code> is the instance class.</p>
<pre><code>function ExampleDecorator(instance: ExampleClass, name: String, type: Class): void {
    /* ExampleDecorator... */
}
class ExampleClass {
    [ExampleDecorator]
    public var x: Number;
}
</code></pre>
<h2 id="instance-methods-1"><a class="header" href="#instance-methods-1">Instance methods</a></h2>
<p>A decorator meta-data applied to an instance method must contain a signature <code>(instance: C, name: String) =&gt; void</code>, where <code>C</code> is the instance class.</p>
<pre><code>function ExampleDecorator(instance: ExampleClass, name: String): void {
    /* ExampleDecorator... */
}
class ExampleClass {
    [ExampleDecorator]
    public function f(): void {}
}
</code></pre>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<p>A decorator meta-data applied to a type definition must contain a signature <code>(type: Class) =&gt; void</code>.</p>
<pre><code>function ExampleDecorator(type: Class): void {
    /* ExampleDecorator... */
}
[ExampleDecorator]
class ExampleClass {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plain-meta-data"><a class="header" href="#plain-meta-data">Plain meta-data</a></h1>
<p>Plain meta-data are uninterpreted meta-data attached to a definition, using double bracketed notation (<code>[[]]</code>).</p>
<p>Plain meta-data consists of a <code>Name()</code> or <code>Name</code> form that consists of zero or more entries. The following are the possible entry forms:</p>
<ul>
<li><code>key = &quot;value&quot;</code> — String entry</li>
<li><code>key = boolean</code> — Boolean entry</li>
<li><code>key = number</code> — Number entry</li>
<li><code>key = File(&quot;path/to/file&quot;)</code> — File entry</li>
<li><code>key = (...)</code> — Entry consisting of a collection of other key-value entries</li>
<li><code>value</code> — Keyless string entry, equivalent to <code>&quot;value&quot;</code></li>
<li><code>&quot;value&quot;</code> — Keyless string entry, equivalent to <code>value</code></li>
<li><code>boolean</code> — Keyless boolean entry</li>
<li><code>number</code> — Keyless number entry</li>
<li><code>File(&quot;path/to/file&quot;)</code> — Keyless file entry</li>
<li><code>(...)</code> — Keyless entry consisting of a collection of other key-value entries</li>
</ul>
<p>Additional syntax and characteristics:</p>
<ul>
<li>The identifiers used in the meta-data form and the entries are allowed to use a <code>::</code> separator, as in <code>q::N</code>.</li>
<li><code>boolean</code> is a <em>BooleanLiteral</em>.</li>
<li><code>number</code> is a <em>NumericLiteral</em> and corresponds to a double-precision floating point.</li>
</ul>
<pre><code>[[N1(x = &quot;y&quot;, z, &quot;w&quot;, File(&quot;myExtension.dll&quot;))]]
[[N2]]
[[N3(x = (x = &quot;v&quot;, y = &quot;v&quot;), y = &quot;v&quot;)]]
class C {}
</code></pre>
<p>The entry keys are not unique and may appear more than once.</p>
<h2 id="file"><a class="header" href="#file">File</a></h2>
<p>The <code>File</code> value of a file entry may be in one of the forms:</p>
<ul>
<li><code>File(&quot;path/to/file&quot;)</code></li>
<li><code>File(outputPath, &quot;path/to/file&quot;)</code> — Resolves file from the output directory of the JetPM build process.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aliases"><a class="header" href="#aliases">Aliases</a></h1>
<p>An alias is a symbol that translates to another symbol. Aliases are a result from <code>type</code> definitions and alias <code>import</code> directives.</p>
<pre><code>type Double = Number;
import N2 = p.N1;
// Package alias
import p2 = p.*;
</code></pre>
<p>Aliases consist of the following internal properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Internal property</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Name</em>]]</td><td>The unqualified name of the alias.</td></tr>
<tr><td>[[<em>Visibility</em>]]</td><td>The <a href="visibility.html">visibility</a> of the alias.</td></tr>
<tr><td>[[<em>AliasOf</em>]]</td><td>The symbol to which this alias translates.</td></tr>
<tr><td>[[<em>ParentDefinition</em>]]</td><td>The parent definition of the alias.</td></tr>
</tbody></table>
</div>
<h2 id="parent-definition-3"><a class="header" href="#parent-definition-3">Parent definition</a></h2>
<p>When the parent definition of an alias is a package, the alias has a fully package qualified name.</p>
<h2 id="resolvealias"><a class="header" href="#resolvealias">ResolveAlias()</a></h2>
<p>The internal <em>ResolveAlias</em>(<em>type</em>) function takes the following steps:</p>
<ol>
<li>If <em>type</em> is an alias, return <em>ResolveAlias</em>(<em>type</em>[[<em>AliasOf</em>]]).</li>
<li>Return <em>type</em>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerations"><a class="header" href="#enumerations">Enumerations</a></h1>
<p>The language supports user enumerations based on (<em>string</em>, <em>number</em>) groups. Enumerations are defined using the <code>enum</code> keyword.</p>
<p>An enumeration is a final class that inherits the <code>Object</code> type.</p>
<pre><code>enum FoodType {
    const LIQUID;
    const SOLID;
}
</code></pre>
<h2 id="members"><a class="header" href="#members">Members</a></h2>
<p>A single enumeration member consists of a (<em>string</em>, <em>number</em>) group. Members within the <code>enum</code> block are defined using non <code>static</code>, <code>const</code> definitions, without destructuring and without a type annotation. The <em>string</em> and <em>number</em> values are corresponding to a <code>String</code> and a number.</p>
<p>The value for <em>string</em> and <em>number</em> may be specified in different forms. If in any of the forms a component is omitted, the value is automatically assigned to that component. The values for the (<em>string</em>, <em>number</em>) group are given in the initializer of the <code>const</code> definition, as follows:</p>
<pre><code>const M;
const M = &quot;string&quot;;
const M = number;
const M = [&quot;string&quot;, number];
const M = [number, &quot;string&quot;];
</code></pre>
<p>In the presented forms, <code>number</code> must be a constant expression that is a number constant whose type is the representation type.</p>
<p>It is a verify error if any of the following conditions are true:</p>
<ul>
<li>The member name already exists.</li>
<li>The <em>string</em> already belongs to another member.</li>
<li>The <em>number</em> already belongs to another member.</li>
<li>If it is a <code>Set</code> enumeration and the <em>number</em> is not one or a power of two.</li>
</ul>
<h3 id="automatic-string"><a class="header" href="#automatic-string">Automatic string</a></h3>
<p>If the <em>string</em> component is omitted when defining a member, its value is a screaming snake case to camel case transformation of the member name, as illustrated in the following table:</p>
<div class="table-wrapper"><table><thead><tr><th>Member name</th><th>Member string</th></tr></thead><tbody>
<tr><td><code>M</code></td><td><code>&quot;m&quot;</code></td></tr>
<tr><td><code>SOME_MEMBER</code></td><td><code>&quot;someMember&quot;</code></td></tr>
<tr><td><code>SOME_BBQ</code></td><td><code>&quot;someBbq&quot;</code></td></tr>
</tbody></table>
</div>
<h3 id="automatic-number"><a class="header" href="#automatic-number">Automatic number</a></h3>
<p>If the <em>number</em> component is omitted when defining a member, its value is selected based on the previous member definition.</p>
<p>For non <code>Set</code> enumerations, the initial member number is zero (0) and the next member number is an increment of 1 of the previous member number:</p>
<pre><code>const M1 // = 0
const M2 // = 1
</code></pre>
<p>For <code>Set</code> enumerations, the initial member number is one (1) and the next member number is the double of the previous member number:</p>
<pre><code>const M1 // = 1
const M2 // = 2
const M4 // = 4
</code></pre>
<h2 id="representation-type"><a class="header" href="#representation-type">Representation type</a></h2>
<p>Enumerations consist of a representation number type. The representation number type may be specified by the <code>Number</code> meta-data, given an identifier identifying the number type.</p>
<p>By default, an enumeration uses <code>Number</code> as the representation number type.</p>
<pre><code>[Number(UnsignedInt)]
enum ExampleEnum {
    const EXAMPLE_MEMBER;
}
</code></pre>
<h2 id="set-enumerations"><a class="header" href="#set-enumerations">Set enumerations</a></h2>
<p>Set enumerations are defined with the <code>Set</code> meta-data. Set enumerations are represented by zero or more members, using bitwise capabilities.</p>
<pre><code>[Set]
enum Toggles {
    const TOGGLE_1;
    const TOGGLE_2;
}
</code></pre>
<h2 id="enumeration-inference"><a class="header" href="#enumeration-inference">Enumeration inference</a></h2>
<p>Throughout JetWork code, the user is allowed to use a string literal to identify an enumeration member by its <em>string</em> value wherever the enumeration is expected at compile-time.</p>
<pre><code>function peopleEat(foodType: FoodType): Boolean (
    foodType == &quot;solid&quot;
);
trace(peopleEat(&quot;solid&quot;));
</code></pre>
<p>Set enumerations can additionally be initialized through an array or object initializer.</p>
<h2 id="conversion"><a class="header" href="#conversion">Conversion</a></h2>
<p>It is allowed to convert to an enumeration using the call operator. The conversion accepts a <code>String</code> or a number of the representation type. It is a <code>TypeError</code> if such conversions fail due to unrecognized <code>String</code> or number. For set enumerations, converting from a number always succeeds, as the members are identified by the corresponding bits and the unrecognized bits are ignored.</p>
<pre><code>E(v)
</code></pre>
<h2 id="native-methods"><a class="header" href="#native-methods">Native methods</a></h2>
<p>Enumerations automatically define the following methods, where <code>N</code> is the representation type:</p>
<pre><code>/**
 * The number value.
 */
public native function valueOf(): N;

/**
 * The string value(s). For a set enumeration, returns a comma-separated string list.
 */
override public native function toString(): String;
</code></pre>
<p>Set enumerations automatically define the following constants, where <code>E</code> is the enumeration:</p>
<pre><code>/**
 * A set containing all members.
 */
public static const all: E;
</code></pre>
<p>Set enumerations automatically define the following methods, where <code>E</code> is the enumeration:</p>
<pre><code>public function include(other: E): E (
    E(this.valueOf() | other.valueOf())
);

public function exclude(other: E): E (
    E(other in this ? this.valueOf() ^ other.valueOf() : this.valueOf())
);

public function toggle(other: E): E (
    E(this.valueOf() ^ other.valueOf())
);

public function filter(other: E): E (
    E(this.valueOf() &amp; other.valueOf())
);

proxy function has(value: E): Boolean (
    this.valueOf() &amp; value.valueOf() != 0
);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<p>A class as denoted by the <code>class</code> keyword represents an object type.</p>
<p>Classes consist of several internal properties, as described in the following table:</p>
<div class="table-wrapper"><table><thead><tr><th>Internal property</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Name</em>]]</td><td>The unqualified name of the class.</td></tr>
<tr><td>[[<em>Visibility</em>]]</td><td>The <a href="visibility.html">visibility</a> of the class.</td></tr>
<tr><td>[[<em>ParentDefinition</em>]]</td><td>The parent definition of the class.</td></tr>
<tr><td>[[<em>SuperClass</em>]]</td><td>The super class of the class. It is undefined if the class is the <code>Object</code> class.</td></tr>
<tr><td>[[<em>Implements</em>]]</td><td>Set of interfaces the class implements.</td></tr>
<tr><td>[[<em>IsFinal</em>]]</td><td>Indicates whether the class is final or not.</td></tr>
<tr><td>[[<em>IsStatic</em>]]</td><td>Indicates whether the class is static or not.</td></tr>
<tr><td>[[<em>IsAbstract</em>]]</td><td>Indicates whether the class is abstract or not.</td></tr>
<tr><td>[[<em>AllowLiteral</em>]]</td><td>Indicates whether the class may be initialized through an object initializer or not; that is, if it has the <code>[Literal]</code> meta-data.</td></tr>
<tr><td>[[<em>TypeParameters</em>]]</td><td>The type parameter sequence of the class.</td></tr>
<tr><td>[[<em>StaticProperties</em>]]</td><td>Static properties of the class.</td></tr>
<tr><td>[[<em>Prototype</em>]]</td><td>Properties of the class prototype as a dictionary from string to symbol.</td></tr>
<tr><td>[[<em>Proxies</em>]]</td><td>Proxies defined by the class as a dictionary from string to function symbol.</td></tr>
<tr><td>[[<em>JXMLColor</em>]]</td><td>For a JXML base class, indicates the supported color class.</td></tr>
<tr><td>[[<em>JXMLVectors</em>]]</td><td>For a JXML base class, indicates the supported vector classes.</td></tr>
<tr><td>[[<em>PlainMetadata</em>]]</td><td>Plain meta-data attached to the class.</td></tr>
</tbody></table>
</div>
<h2 id="super-class"><a class="header" href="#super-class">Super class</a></h2>
<p>By default, all classes, excluding <code>Object</code>, have <code>Object</code> as their super class.</p>
<p>It is a verify error if:</p>
<ul>
<li>a class attempts to extend itself;</li>
<li>a class attempts to extend a subclass of itself.</li>
</ul>
<h2 id="parent-definition-4"><a class="header" href="#parent-definition-4">Parent definition</a></h2>
<p>When the parent definition of a class is a package, the class has a fully package qualified name.</p>
<h2 id="jxml-color-and-vector-support"><a class="header" href="#jxml-color-and-vector-support">JXML color and vector support</a></h2>
<p>A JXML base class may contain a <code>JXML</code> meta-data with two optional options <code>colorClass</code> and <code>vectorClass</code> that specify the fully package qualified name of a support class for the color and vector classes to use throughout XML attribute values in JXML files.</p>
<ul>
<li>It is a verify error if the fully package qualified names specified within <code>JXML</code> do not resolve to a class.</li>
<li>It is a verify error if the class specified by <code>colorClass</code> does not contain a constructor with the signature <code>(...arguments: [*]) =&gt; void</code>.</li>
<li>It is a verify error if the class specified by <code>vectorClass</code> does not contain a constructor that takes parameters of a same number type.</li>
<li>Only one <code>colorClass</code> occurrence is allowed, contributing the class to the annotated class [[<em>JXMLColor</em>]] property.</li>
<li>Multiple <code>vectorClass</code> occurrences are allowed, contributing multiple classes to the annotated class [[<em>JXMLVectors</em>]] property.</li>
</ul>
<pre><code>package org.myEngine {
    [JXML(
        colorClass = org.myEngine.Color,
        vectorClass = org.myEngine.Vector,
        vectorClass = org.myEngine.Vector3D
    )]
    public abstract class Node implements JXML {
        /* JXML... */
    }
}
</code></pre>
<h2 id="meta-data-3"><a class="header" href="#meta-data-3">Meta data</a></h2>
<p>A class may contain zero or more plain meta-data:</p>
<pre><code>[[N1(n2)]]
class C {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h1>
<p>An interface as denoted by the <code>interface</code> keyword represents an abstract object type.</p>
<p>Interfaces consist of a small number of internal properties, described in the following table:</p>
<div class="table-wrapper"><table><thead><tr><th>Internal property</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Name</em>]]</td><td>The unqualified name of the interface.</td></tr>
<tr><td>[[<em>Visibility</em>]]</td><td>The <a href="visibility.html">visibility</a> of the interface.</td></tr>
<tr><td>[[<em>ParentDefinition</em>]]</td><td>The parent definition of the interface.</td></tr>
<tr><td>[[<em>SuperInterfaces</em>]]</td><td>The super interfaces of the interface.</td></tr>
<tr><td>[[<em>TypeParameters</em>]]</td><td>The type parameter sequence of the interface.</td></tr>
<tr><td>[[<em>Prototype</em>]]</td><td>Properties of the interface prototype as a dictionary from string to symbol.</td></tr>
<tr><td>[[<em>PlainMetadata</em>]]</td><td>Plain meta-data attached to the interface.</td></tr>
</tbody></table>
</div>
<h2 id="super-interfaces"><a class="header" href="#super-interfaces">Super interfaces</a></h2>
<p>It is a verify error if:</p>
<ul>
<li>an interface attempts to extend itself;</li>
<li>an interface attempts to extend a subtype of itself.</li>
</ul>
<h2 id="parent-definition-5"><a class="header" href="#parent-definition-5">Parent definition</a></h2>
<p>When the parent definition of an interface is a package, the interface has a fully package qualified name.</p>
<h2 id="meta-data-4"><a class="header" href="#meta-data-4">Meta data</a></h2>
<p>An interface may contain zero or more plain meta-data:</p>
<pre><code>[[N1(n2)]]
interface I {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jxml-components-1"><a class="header" href="#jxml-components-1">JXML components</a></h1>
<!--

Future data binding support:

* Consider using a particular XML namespace for data binding attributes (prefix usually being "bind").
* A p={o.p} attribute would be a data binding if o is a binding from within the JXML component

-->
<p>A JXML component is a XML file with the extension <code>.jxml</code> describing a class that inherits from a <code>JXML</code> implementor.</p>
<p>The class described in the XML file is referred throughout this section as <em>descClass</em>.</p>
<h2 id="root-element"><a class="header" href="#root-element">Root element</a></h2>
<p>The following semantics apply to the root element:</p>
<ul>
<li>The root element of the XML file is a JXML instantiation. The component of the JXML instantiation is the class from which <em>descClass</em> inherits.</li>
<li>The root element must assign the attribute <code>className</code> a fully package qualified name whose trailing name identifies the class name of <em>descClass</em>, as in:</li>
</ul>
<pre><code class="language-xml">&lt;e:Application xmlns:e=&quot;org.example&quot; className=&quot;org.example.Main&quot;&gt;
    &lt;!-- org.example.Main --&gt;
&lt;/e:Application&gt;
</code></pre>
<p>Such XML file results into defining <em>descClass</em> as a <code>Main</code> class that belongs to the <code>org.example</code> package. It is a verify error if the class is already defined.</p>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<p>The constructor of <em>descClass</em> is implicitly defined if not already defined by the <code>&lt;Script&gt;</code> element.</p>
<p>The following restrictions apply to JXML components:</p>
<ul>
<li>The constructor of <em>descClass</em> is only allowed to receive optional parameters.</li>
</ul>
<h2 id="script-1"><a class="header" href="#script-1">&lt;Script&gt;</a></h2>
<p>The <code>Script</code> element is allowed at the root element and may appear at most once. If an <code>Script</code> element appears, it must only contain a CDATA section.</p>
<p>The CDATA section contains a JetWork source as the contents of a <code>class</code> block. Such contents are contributed to <em>descClass</em>.</p>
<p>The <code>Script</code> element must be interpreted before the XML attributes of the root element are processed. This behavior allows code in attribute values to rely on <code>import</code> directives, as in the following JXML component:</p>
<pre><code class="language-xml">&lt;e:Application xmlns:e=&quot;org.example&quot;
    className=&quot;org.example.Main&quot;
    rectangle=&quot;{new Rectangle(0, 0, 100, 100)}&quot;&gt;
    &lt;Script&gt;
        import org.foundation.geom.*;
    &lt;/Script&gt;
&lt;/e:Application&gt;
</code></pre>
<h2 id="children-1"><a class="header" href="#children-1">&lt;Children/&gt;</a></h2>
<p>The empty <code>Children</code> element is allowed anywhere within the root element and may appear at most once.</p>
<p>The <code>Children</code> tag is replaced by zero or more JXML instantiations that appear as children of the JXML component.</p>
<pre><code class="language-xml">&lt;e:C1 xmlns:e=&quot;org.example&quot; className=&quot;org.example.C2&quot;&gt;
    &lt;Children/&gt;
&lt;/e:C1&gt;
</code></pre>
<h2 id="jxml-instantiation"><a class="header" href="#jxml-instantiation">JXML instantiation</a></h2>
<p>All XML elements that are not of the empty namespace are JXML instantiations. Given that <em>comp</em> is the component being instantiated:</p>
<ul>
<li><em>comp</em> is valid if and only if the tag name identifies a fully package qualified class that implements the <code>JXML</code> interface, where the tag namespace identifies the package and the tag unqualified name identifies the class name.</li>
<li>A JXML instantiation creates a <em>scope</em> scope and returns <code>result = new comp()</code> followed by processing of attributes followed by children processing.</li>
</ul>
<p>The <em>scope</em> scope is created as follows:</p>
<ul>
<li>Let <em>scope</em> be an empty scope.</li>
<li>Let <em>classScope</em> be the scope of the <em>descClass</em> block.</li>
<li>For each <em>p</em> in <em>classScope</em>[[<em>Imports</em>]]
<ul>
<li>Contribute <em>p</em> to <em>scope</em>[[<em>Imports</em>]]</li>
</ul>
</li>
<li>For each <em>p</em> in <em>classScope</em>[[<em>OpenPackages</em>]]
<ul>
<li>Contribute <em>p</em> to <em>scope</em>[[<em>OpenPackages</em>]]</li>
</ul>
</li>
<li>For each <em>p</em> in <em>classScope</em>[[<em>Properties</em>]]
<ul>
<li>If <em>p</em> is an alias
<ul>
<li>Contribute <em>p</em> to <em>scope</em>[[<em>Properties</em>]]</li>
</ul>
</li>
</ul>
</li>
<li>Return <em>scope</em>.</li>
</ul>
<p>Attributes are processed as follows:</p>
<ul>
<li>Inside <em>scope</em>
<ul>
<li>For each XML attribute of the instantiation tag
<ul>
<li>If the XML attribute name is not <strong>className</strong>
<ul>
<li>Call <em>AssignJXMLAttribute</em>(<em>comp</em>, <em>scope</em>, XML attribute)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Children are processed as follows:</p>
<ul>
<li>If <em>comp</em> contains a <code>&lt;Children/&gt;</code> tag
<ul>
<li>Move children to the location of the <code>&lt;Children/&gt;</code> tag.</li>
<li>Remove the <code>&lt;Children/&gt;</code> tag.</li>
</ul>
</li>
<li>Otherwise
<ul>
<li>For each child JXML instantiation <em>ji</em>
<ul>
<li>Call <code>result.jxmlAppend()</code> passing the result of <em>ji</em>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="assignjxmlattribute"><a class="header" href="#assignjxmlattribute">AssignJXMLAttribute()</a></h3>
<p>The internal <em>AssignJXMLAttribute</em>(<em>comp</em>, <em>scope</em>, XML attribute) function takes the following steps:</p>
<ol>
<li>Let <em>p</em> be a property of the result object whose name matches the attribute unqualified name.</li>
<li>It is a verify error if either <em>p</em> is not defined or <em>p</em> is read-only.</li>
<li>It is a verify error if <em>p</em> is neither a variable property or a virtual property.</li>
<li>Let <em>t</em> be the static type of <em>p</em>.</li>
<li>If the attribute value starts with the <strong>{</strong> character and ends with the <strong>}</strong> character
<ol>
<li>Call <em>AssignJXMLExpressionAttribute</em>(<em>comp</em>, <em>scope</em>, <em>p</em>, <em>t</em>, XML attribute)</li>
</ol>
</li>
<li>Otherwise
<ol>
<li>Call <em>AssignJXMLConstantAttribute</em>(<em>comp</em>, <em>p</em>, <em>t</em>, XML attribute)</li>
<li>Otherwise:
<ol>
<li>Call <em>AssignJXMLColorAttribute</em>(<em>comp</em>, <em>p</em>, <em>t</em>, XML attribute)</li>
<li>Otherwise call <em>AssignJXMLVectorAttribute</em>(<em>comp</em>, <em>p</em>, <em>t</em>, XML attribute)</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="assignjxmlexpressionattribute"><a class="header" href="#assignjxmlexpressionattribute">AssignJXMLExpressionAttribute()</a></h3>
<p>The internal <em>AssignJXMLExpressionAttribute</em>(<em>comp</em>, <em>scope</em>, <em>p</em>, <em>t</em>, XML attribute) function takes the following steps:</p>
<ol>
<li>Let <em>src</em> be a substring of the attribute value from the second character until the last character (<strong>}</strong>).</li>
<li>Let <em>v</em> be the verification of <em>src</em> as an <em>AssignmentExpression</em> with the context type <em>t</em> and with the initial scope as <em>scope</em>.</li>
<li>Assign <em>v</em> = implicit conversion from <em>v</em> to <em>t</em>.</li>
<li>It is a verify error if <em>v</em> is an incompatible conversion.</li>
<li>Assign <em>p</em> the evaluation of <em>v</em></li>
</ol>
<h3 id="assignjxmlconstantattribute"><a class="header" href="#assignjxmlconstantattribute">AssignJXMLConstantAttribute()</a></h3>
<p>The internal <em>AssignJXMLConstantAttribute</em>(<em>comp</em>, <em>p</em>, <em>t</em>, XML attribute) function takes the following steps:</p>
<ol>
<li>If <em>t</em> is <code>N</code> or <code>Optional.&lt;N&gt;</code> where <code>N</code> is a number type
<ol>
<li>Assign <em>AttributeValueToNumber</em>(<em>v</em>, <code>N</code>) to <em>p</em> where <em>v</em> is the attribute value.</li>
<li>Exit function</li>
</ol>
</li>
<li>If <em>t</em> is <code>Boolean</code> or <code>Optional.&lt;Boolean&gt;</code> and the attribute value is <code>false</code> or <code>true</code>, 
<ol>
<li>Assign the equivalent boolean constant of that attribute value to <em>p</em>.</li>
<li>Exit function</li>
</ol>
</li>
<li>If <em>t</em> is <code>Char</code> or <code>Optional.&lt;Char&gt;</code>
<ol>
<li>Assert that the attribute value consists of one character.</li>
<li>Assign the first Unicode Code Point of the attribute value to <em>p</em>.</li>
<li>Exit function</li>
</ol>
</li>
<li>If <em>t</em> is <code>String</code> or <code>Optional.&lt;String&gt;</code>
<ol>
<li>Assign the attribute value to <em>p</em>.</li>
<li>Exit function</li>
</ol>
</li>
<li>If <em>t</em> is <code>E</code> or <code>Optional.&lt;E&gt;</code> where <code>E</code> is a non Set <code>enum</code>
<ol>
<li>Assert that the attribute value identifies a member of the <code>enum</code> by its string component and assign such member to <em>p</em>.</li>
<li>Exit function</li>
</ol>
</li>
<li>If <em>t</em> is <code>E</code> or <code>Optional.&lt;E&gt;</code> where <code>E</code> is a Set <code>enum</code>.
<ol>
<li>Assert that the attribute value is a comma-separated list identifying one or more members of the <code>enum</code> by their string components.</li>
<li>Assign such members to <em>p</em>.</li>
<li>Exit function</li>
</ol>
</li>
<li>Return assignment failure.</li>
</ol>
<h3 id="assignjxmlcolorattribute"><a class="header" href="#assignjxmlcolorattribute">AssignJXMLColorAttribute()</a></h3>
<p>The internal <em>AssignJXMLColorAttribute</em>(<em>comp</em>, <em>p</em>, <em>t</em>, XML attribute) function takes the following steps:</p>
<ol>
<li>Let <em>colorClass</em> be [[<em>JXMLColor</em>]] from either <em>comp</em> or a super class of <em>comp</em>.</li>
<li>If <em>colorClass</em> exists and <em>t</em> is equals <em>colorClass</em>, assign <code>new colorClass(v)</code> to <em>p</em> where <code>v</code> is the attribute value as a <code>String</code>.</li>
<li>Otherwise return assignment failure.</li>
</ol>
<h3 id="assignjxmlvectorattribute"><a class="header" href="#assignjxmlvectorattribute">AssignJXMLVectorAttribute()</a></h3>
<p>The internal <em>AssignJXMLVectorAttribute</em>(<em>comp</em>, <em>p</em>, <em>t</em>, XML attribute) function takes the following steps:</p>
<ol>
<li>Let <em>vectorClasses</em> be [[<em>JXMLVectors</em>]] from either <em>comp</em> or a super class of <em>comp</em>.</li>
<li>Let <em>vectorComponents</em> be the result of spliting the attribute value by comma.</li>
<li>If a class <em>vectorClass</em> from <em>vectorClasses</em> has a constructor whose number of formal parameters equals to the length of <em>vectorComponents</em> and <em>t</em> is equals <em>vectorClass</em>, assign <em>p</em> the expression <code>new vectorClass(...)</code> passing every value from the sequence returned by <em>StringsToNumbers</em>(<em>vectorComponents</em>, <em>N</em>) with <em>N</em> being the number type expected by the <em>vectorClass</em> constructor's formal parameters.</li>
<li>Otherwise return assignment failure.</li>
</ol>
<h3 id="attributevaluetonumber"><a class="header" href="#attributevaluetonumber">AttributeValueToNumber()</a></h3>
<p>The internal <em>AttributeValueToNumber</em>(<em>s</em>, <em>N</em>) function takes a string <em>s</em> and returns a number of a specific number type <em>N</em>. The function performs the following steps:</p>
<ul>
<li>Let <em>s</em> be the result of trimming Unicode Whitespace characters out of both ends of <em>s</em>.</li>
<li>If <em>N</em> is a floating point type and <em>s</em> is one of { <code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>, <code>+Infinity</code> }, return the <em>N</em> representation of <em>s</em> as a floating point constant.</li>
<li>Return the mathematical value of <em>s</em> as a <em>DecimalLiteral</em> or <em>HexIntegerLiteral</em>.</li>
</ul>
<h3 id="stringstonumbers"><a class="header" href="#stringstonumbers">StringsToNumbers()</a></h3>
<p>The internal <em>StringsToNumbers</em>(<em>seq</em>, <em>N</em>) function takes a sequence of strings <em>seq</em> and returns a number sequence of a specific number type <em>N</em>. The function returns a processing of every element <em>s</em> in <em>seq</em> as the result of calling <em>AttributeValueToNumber</em>(<em>s</em>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property-resolution"><a class="header" href="#property-resolution">Property resolution</a></h1>
<h2 id="resolveproperty"><a class="header" href="#resolveproperty">ResolveProperty()</a></h2>
<p>The internal <em>ResolveProperty</em>(<em>base</em>, <em>qual</em>, <em>key</em>) function takes a <em>base</em> object, a <em>qual</em> qualifier value and a <em>key</em> value, and resolves to a reference value. <em>ResolveProperty</em> takes the following steps:</p>
<ol>
<li>If <em>base</em> is a value whose type is one of { <code>XML</code>, <code>XMLList</code> }, return <em>XMLReferenceValue</em>(<em>base</em>, <em>qual</em>, <em>key</em>).</li>
<li>If <em>base</em> is a scope, return <em>ResolveScopeProperty</em>(<em>base</em>, <em>qual</em>, <em>key</em>).</li>
<li>If <em>base</em> is a value whose type is <code>*</code>
<ol>
<li>Return <em>DynamicReferenceValue</em>(<em>base</em>, <em>qual</em>, <em>key</em>)</li>
</ol>
</li>
<li>Return undefined if <em>qual</em> is defined.</li>
<li>If <em>base</em> is a <code>class</code> or <code>enum</code>
<ol>
<li>Return undefined if <em>key</em> is not a <code>String</code> value.</li>
<li>While <em>base</em> is defined
<ol>
<li>Let <em>r</em> be the symbol in <em>base</em>[[<em>StaticProperties</em>]] whose key is equals <em>key</em>.</li>
<li>Return <em>StaticReferenceValue</em>(<em>base</em>, <em>r</em>) if <em>r</em> is defined.</li>
<li>Assign <em>base</em> = <em>base</em>[[<em>SuperClass</em>]]</li>
</ol>
</li>
<li>Return undefined.</li>
</ol>
</li>
<li>If <em>base</em> is a value
<ol>
<li>Return undefined if the type of <em>base</em> is <code>undefined</code>.</li>
<li>If <em>key</em> is a <code>String</code> value
<ol>
<li>For each descending <em>type</em> in the type hierarchy of <em>base</em>
<ol>
<li>For each <em>prop</em> in <em>type</em>[[<em>Prototype</em>]]
<ol>
<li>If <em>prop</em>[[<em>Name</em>]] is equals <em>key</em>, return <em>InstanceReferenceValue</em>(<em>base</em>, <em>prop</em>).</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>For each descending <em>type</em> in the type hierarchy of <em>base</em>
<ol>
<li>Let <em>proxy</em> be <em>FindPropertyProxy</em>(<em>type</em>)</li>
<li>If <em>proxy</em> is defined
<ol>
<li>If the first parameter type of <em>proxy</em> is equals the type of <em>key</em> or if the type of <em>key</em> is a subtype of the first parameter type of <em>proxy</em>
<ol>
<li>Return <em>ProxyReferenceValue</em>(<em>base</em>, <em>proxy</em>)</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>If <em>key</em> is a <code>Number</code> value and <em>base</em> is of a tuple type
<ol>
<li>Let <em>key</em> be <em>ToUInt32</em>(<em>key</em>)</li>
<li>Assuming <em>key</em> to be a zero-based index, if the <em>key</em> index is not out of bounds of the element sequence of the tuple type of <em>base</em>
<ol>
<li>Return <em>TupleReferenceValue</em>(<em>base</em>, <em>key</em>).</li>
</ol>
</li>
</ol>
</li>
<li>Return undefined.</li>
</ol>
</li>
<li>If <em>base</em> is a <code>package</code>
<ol>
<li>Return undefined if <em>key</em> is not a <code>String</code> value.</li>
<li>Let <em>r</em> be a symbol in <em>base</em>[[<em>Properties</em>]] whose key is equals <em>key</em>.</li>
<li>Return <em>WrapPropertyReference</em>(<em>ResolveAlias</em>(<em>r</em>)) if <em>r</em> is defined.</li>
<li>For each <em>p</em> in <em>base</em>[[<em>WildcardUses</em>]]
<ol>
<li>Let <em>r</em> be <em>ResolveProperty</em>(<em>p</em>, undefined, <em>key</em>)</li>
<li>Return <em>r</em> if it is defined.</li>
</ol>
</li>
<li>Return undefined.</li>
</ol>
</li>
<li>Return undefined.</li>
</ol>
<h2 id="findpropertyproxy"><a class="header" href="#findpropertyproxy">FindPropertyProxy()</a></h2>
<p>The internal <em>FindPropertyProxy</em>(<em>type</em>) function takes the following steps:</p>
<ol>
<li>Return undefined if <em>type</em> does not contain [[<em>Proxies</em>]].</li>
<li>Return a function of <em>type</em>[[<em>Proxies</em>]] whose key equals <code>getProperty</code>.</li>
</ol>
<h2 id="resolvescopeproperty"><a class="header" href="#resolvescopeproperty">ResolveScopeProperty()</a></h2>
<p>The internal <em>ResolveScopeProperty</em>(<em>base</em>, <em>qual</em>, <em>key</em>) takes the following steps:</p>
<ol>
<li>If <em>base</em> is a <code>with</code> scope
<ol>
<li>If <em>base</em>[[<em>Object</em>]] is of one of the types { <code>*</code>, <code>XML</code>, <code>XMLList</code> }
<ol>
<li>Return <em>DynamicScopeReferenceValue</em>(<em>base</em>, <em>qual</em>, <em>key</em>)</li>
</ol>
</li>
<li>Let <em>r</em> be <em>ResolveProperty</em>(<em>base</em>[[<em>Object</em>]], <em>qual</em>, <em>key</em>)</li>
<li>Return <em>r</em> if it is defined.</li>
</ol>
</li>
<li>If <em>base</em> is a filter operator scope
<ol>
<li>Return <em>DynamicScopeReferenceValue</em>(<em>base</em>, <em>qual</em>, <em>key</em>).</li>
</ol>
</li>
<li>Throw a verify error if either <em>qual</em> is defined or <em>key</em> is not a <code>String</code> value.</li>
<li>Let <em>r</em> be undefined.</li>
<li>If <em>qual</em> is not defined
<ol>
<li>Assign <em>r</em> = a symbol of <em>base</em>[[<em>Properties</em>]] whose key equals <em>key</em>.</li>
</ol>
</li>
<li>If <em>r</em> is defined
<ol>
<li>Assign <em>r</em> = <em>WrapPropertyReference</em>(<em>ResolveAlias</em>(<em>r</em>))</li>
<li>Return <em>r</em></li>
</ol>
</li>
<li>If <em>base</em> is an activation scope and <em>base</em>[[<em>This</em>]] is defined
<ol>
<li>Assign <em>r</em> = <em>ResolveProperty</em>(<em>base</em>[[<em>This</em>]], <em>qual</em>, <em>key</em>)</li>
<li>Return <em>r</em> if it is defined.</li>
</ol>
</li>
<li>If <em>base</em> is a <code>class</code> or <code>enum</code> scope
<ol>
<li>Assign <em>r</em> = <em>ResolveProperty</em>(<em>base</em>[[<em>Class</em>]], <em>qual</em>, <em>key</em>)</li>
</ol>
</li>
<li>Let <em>amb</em> be undefined.</li>
<li>If <em>base</em> is a <code>package</code> scope
<ol>
<li>Assign <em>amb</em> = <em>ResolveProperty</em>(<em>base</em>[[<em>Package</em>]], <em>qual</em>, <em>key</em>)</li>
<li>It is an ambiguous reference error if <em>r</em> is defined</li>
<li>Assign <em>r</em> = <em>amb</em></li>
</ol>
</li>
<li>If <em>qual</em> is not defined
<ol>
<li>For each <em>p</em> in <em>base</em>[[<em>Imports</em>]]
<ol>
<li>If <em>p</em>[[<em>Name</em>]] equals <em>key</em>
<ol>
<li>Assign <em>amb</em> = <em>WrapPropertyReference</em>(<em>ResolveAlias</em>(<em>p</em>))</li>
<li>It is an ambiguous reference error if <em>r</em> is defined</li>
<li>Assign <em>r</em> = <em>amb</em></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>For each <em>op</em> in <em>base</em>[[<em>OpenPackages</em>]]
<ol>
<li>Assign <em>amb</em> = <em>ResolveProperty</em>(<em>op</em>, <em>qual</em>, <em>key</em>)</li>
<li>It is an ambiguous reference error if <em>r</em> is defined</li>
<li>Assign <em>r</em> = <em>amb</em></li>
</ol>
</li>
<li>If <em>r</em> is not defined and <em>base</em>[[<em>ParentScope</em>]] is defined
<ol>
<li>Return <em>ResolveScopeProperty</em>(<em>base</em>[[<em>ParentScope</em>]], <em>qual</em>, <em>key</em>)</li>
</ol>
</li>
<li>Return <em>r</em></li>
</ol>
<h2 id="wrappropertyreference"><a class="header" href="#wrappropertyreference">WrapPropertyReference()</a></h2>
<p>The internal <em>WrapPropertyReference</em>(<em>prop</em>) function takes the following steps:</p>
<ol>
<li>Let <em>parent</em> be <em>prop</em>[[<em>ParentDefinition</em>]]</li>
<li>If <em>parent</em> is a <code>class</code> or <code>enum</code>, return <em>StaticReferenceValue</em>(<em>parent</em>, <em>prop</em>)</li>
<li>If <em>parent</em> is a <code>package</code>, return <em>PackageReferenceValue</em>(<em>parent</em>, <em>prop</em>)</li>
<li>Assert that <em>parent</em> is a scope.</li>
<li>Return <em>ScopeReferenceValue</em>(<em>parent</em>, <em>prop</em>)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scopes"><a class="header" href="#scopes">Scopes</a></h1>
<p>A scope consists of the following internal properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Internal property</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>ParentScope</em>]]</td><td>The parent scope.</td></tr>
<tr><td>[[<em>Properties</em>]]</td><td>Properties of the scope as a dictionary of string to symbol.</td></tr>
<tr><td>[[<em>Imports</em>]]</td><td>Set of package imported properties.</td></tr>
<tr><td>[[<em>OpenPackages</em>]]</td><td>Set of open packages.</td></tr>
</tbody></table>
</div>
<p>The [[<em>Imports</em>]] property of a scope holds <em>non aliased</em> properties imported from a package.</p>
<p>The [[<em>OpenPackages</em>]] property of a scope holds <em>non aliased</em> opened packages.</p>
<p>An <code>import</code> directive that aliases a property or package contributes an alias to [[<em>Properties</em>]].</p>
<h2 id="with-scope"><a class="header" href="#with-scope">With scope</a></h2>
<p>A <code>with</code> scope in addition consists of the following internal properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Internal property</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Object</em>]]</td><td>The object specified in the <code>with</code> statement.</td></tr>
</tbody></table>
</div>
<h2 id="filter-operator-scope"><a class="header" href="#filter-operator-scope">Filter operator scope</a></h2>
<p>A filter operator scope in addition consists of the following internal properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Internal property</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Base</em>]]</td><td>The base object of the filter operator.</td></tr>
</tbody></table>
</div>
<h2 id="activation-scope"><a class="header" href="#activation-scope">Activation scope</a></h2>
<p>An activation scope in addition consists of the following internal properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Internal property</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Function</em>]]</td><td>The function to which this scope belongs.</td></tr>
<tr><td>[[<em>This</em>]]</td><td>The object returned by the <code>this</code> literal.</td></tr>
</tbody></table>
</div>
<h2 id="class-scope"><a class="header" href="#class-scope">Class scope</a></h2>
<p>A <code>class</code> scope in addition consists of the following internal properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Internal property</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Class</em>]]</td><td>The enclosing class.</td></tr>
</tbody></table>
</div>
<h2 id="enum-scope"><a class="header" href="#enum-scope">Enum scope</a></h2>
<p>A <code>enum</code> scope in addition consists of the following internal properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Internal property</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Class</em>]]</td><td>The enclosing <code>enum</code>.</td></tr>
</tbody></table>
</div>
<h2 id="package-scope"><a class="header" href="#package-scope">Package scope</a></h2>
<p>A <code>package</code> scope in addition consists of the following internal properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Internal property</th><th>Description</th></tr></thead><tbody>
<tr><td>[[<em>Package</em>]]</td><td>The enclosing <code>package</code>.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="type-expressions"><a class="header" href="#type-expressions">Type expressions</a></h1>
<table>
    <tr>
        <td colspan="2"><i>TypeExpression</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>TypeExpression</i><sup>noPrefix</sup></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>?</b> <i>TypeExpression</i><sup>noPrefix</sup></td>
    </tr>
</table>
<table>
    <tr>
        <td colspan="2"><i>TypeExpression</i><sup>noPrefix</sup></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>*</b></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>Identifier</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>void</b></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>undefined</b></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>&#x5B;</b> <i>TypeExpression</i> <b>&#x5D;</b></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>&#x28;</b> <i>TypeExpression</i> <b>&#x29;</b></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>TupleTypeExpression</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>FunctionTypeExpression</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>TypeExpression</i><sup>noPrefix</sup> <b>.</b> <i>IdentifierName</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>TypeExpression</i><sup>noPrefix</sup> <i>TypeArguments</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>TypeExpression</i><sup>noPrefix</sup> <b>?</b></td>
    </tr>
</table>
<table>
    <tr>
        <td colspan="2"><i>TypeArguments</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>.</b> <b>&lt;</b> <i>TypeArgumentsList</i> <b>&gt;</b></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>.</b> <b>&lt;</b> <i>TypeArgumentsList</i> [initial <b>&gt;</b> from the offending token]</td>
    </tr>
</table>
<table>
    <tr>
        <td colspan="2"><i>TypeArgumentsList</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>TypeExpression</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>TypeExpressionList</i> <b>,</b> <i>TypeExpression</i></td>
    </tr>
</table>
<table>
    <tr>
        <td colspan="2"><i>TupleTypeExpression</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>&#x5B;</b> <i>TupleElementTypes</i> <b>&#x5D;</b></td>
    </tr>
</table>
<table>
    <tr>
        <td colspan="2"><i>TupleElementTypes</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i><i>TypeExpression</i> <b>,</b> <i>TypeExpression</i></i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i><i>TupleElementTypes</i> <b>,</b> <i>TypeExpression</i></i></td>
    </tr>
</table>
<table>
    <tr>
        <td colspan="2"><i>FunctionTypeExpression</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>(</b> <i>FunctionTypeParameters</i> <b>)</b> <b>=></b> <i>TypeExpression</i></td>
    </tr>
</table>
<table>
    <tr>
        <td colspan="2"><i>FunctionTypeParameters</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td>[empty]</td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>FunctionTypeParameter</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>FunctionTypeParameters</i> <b>,</b> <i>FunctionTypeParameter</i></td>
    </tr>
</table>
<table>
    <tr>
        <td colspan="2"><i>FunctionTypeParameter</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>TypedIdentifier</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>FunctionTypeOptionalParameter</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><b>...</b> <i>TypedIdentifier</i></td>
    </tr>
</table>
<table>
    <tr>
        <td colspan="2"><i>TypedIdentifier</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>IdentifierName</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>IdentifierName</i> <b>:</b> <i>TypeExpression</i></td>
    </tr>
</table>
<table>
    <tr>
        <td colspan="2"><i>FunctionTypeOptionalParameter</i></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>IdentifierName</i> <b>?</b></td>
    </tr>
    <tr>
        <td>&nbsp;</td><td><i>IdentifierName</i> <b>?</b> <b>:</b> <i>TypeExpression</i></td>
    </tr>
</table>
<p><strong>Verification</strong></p>
<p><i>TypeExpression</i> : <i>TypeExpression</i><sup>noPrefix</sup></p>
<ul>
<li>Return the verification result of <i>TypeExpression</i><sup>noPrefix</sup>.</li>
</ul>
<p><i>TypeExpression</i> : <b>?</b> <i>TypeExpression</i><sup>noPrefix</sup></p>
<ul>
<li>Return the verification result of <i>TypeExpression</i><sup>noPrefix</sup> if it is the <code>Optional</code> type.</li>
<li>Return an <code>Optional</code> type consisting of the verification result of <i>TypeExpression</i><sup>noPrefix</sup>.</li>
</ul>
<p><i>TypeExpression</i><sup>noPrefix</sup> : <b>*</b></p>
<ul>
<li>Return the any type.</li>
</ul>
<p><i>TypeExpression</i><sup>noPrefix</sup> : <i>Identifier</i></p>
<ul>
<li>Let <em>p</em> be <em>ResolveProperty</em>(<em>current scope</em>, undefined, string of <i>Identifier</i>)</li>
<li>It is a verify error if <em>p</em> is undefined.</li>
<li>It is a verify error if <a href="visibility.html#propertyisvisible"><em>PropertyIsVisible</em></a>(<em>p</em>, <em>current scope</em>) is false.</li>
<li>It is a verify error if <em>p</em> is not a type and the rule is not followed by a postfix operator.</li>
<li>Return <em>p</em>.</li>
</ul>
<p><i>TypeExpression</i><sup>noPrefix</sup> : <b>void</b></p>
<ul>
<li>Return the void type.</li>
</ul>
<p><i>TypeExpression</i><sup>noPrefix</sup> : <b>undefined</b></p>
<ul>
<li>Return the void type.</li>
</ul>
<p><i>TypeExpression</i><sup>noPrefix</sup> : <i>TupleTypeExpression</i></p>
<ul>
<li>Return the verification of <i>TupleTypeExpression</i>.</li>
</ul>
<p><i>TypeExpression</i><sup>noPrefix</sup> : <i>FunctionTypeExpression</i></p>
<ul>
<li>Return the verification of <i>FunctionTypeExpression</i>.</li>
</ul>
<p><i>TypeExpression</i><sup>noPrefix</sup> : <b>[</b> <i>TypeExpression</i> <b>]</b></p>
<ul>
<li>Return an array type consisting of the verification result of <i>TypeExpression</i>.</li>
</ul>
<p><i>TypeExpression</i><sup>noPrefix</sup> : <b>(</b> <i>TypeExpression</i> <b>)</b></p>
<ul>
<li>Return the verification result of <i>TypeExpression</i>.</li>
</ul>
<p><i>TypeExpression</i><sup>noPrefix</sup> : <i>TypeExpression</i><sup>noPrefix</sup> <b>.</b> <i>IdentifierName</i></p>
<ul>
<li>Let <em>base</em> be the verification result of <i>TypeExpression</i><sup>noPrefix</sup>.</li>
<li>Let <em>p</em> be <em>ResolveProperty</em>(<em>base</em>, undefined, string of <i>IdentifierName</i>)</li>
<li>It is a verify error if <em>p</em> is undefined.</li>
<li>It is a verify error if <a href="visibility.html#propertyisvisible"><em>PropertyIsVisible</em></a>(<em>p</em>, <em>current scope</em>) is false.</li>
<li>Return <em>p</em>.</li>
</ul>
<p><i>TypeExpression</i><sup>noPrefix</sup> : <i>TypeExpression</i><sup>noPrefix</sup> <i>TypeArguments</i></p>
<ul>
<li>Let <em>base</em> be the verification result of <i>TypeExpression</i><sup>noPrefix</sup>.</li>
<li>It is a verify error if <em>base</em> is not a type with [[<em>TypeParameters</em>]].</li>
<li>It is a verify error if <em>base</em>[[<em>TypeParameters</em>]] is empty.</li>
<li>Let <em>a</em> be the verification sequence of <i>TypeArguments</i>.</li>
<li>If <em>base</em> is <code>Optional</code> and <em>a</em><sub>0</sub> is <code>Optional</code>
<ul>
<li>Return <em>a</em><sub>0</sub></li>
</ul>
</li>
<li>Return a type substitution in <em>base</em> with <em>a</em> as type arguments.</li>
</ul>
<p><i>TypeExpression</i><sup>noPrefix</sup> : <i>TypeExpression</i><sup>noPrefix</sup> <b>?</b></p>
<ul>
<li>Return the verification result of <i>TypeExpression</i><sup>noPrefix</sup> if it is the <code>Optional</code> type.</li>
<li>Return an <code>Optional</code> type consisting of the verification result of <i>TypeExpression</i><sup>noPrefix</sup>.</li>
</ul>
<p><i>TupleTypeExpression</i> : <b>[</b> <i>TupleElementTypes</i> <b>]</b></p>
<ul>
<li>Let <em>e</em> be an empty list.</li>
<li>For each <em>e</em><sub>0</sub> <i>TypeExpression</i> in <i>TupleElementTypes</i>
<ul>
<li>Append to <em>e</em> the verification result of <em>e</em><sub>0</sub></li>
</ul>
</li>
<li>Return a tuple type consisting of the element types <em>e</em>.</li>
</ul>
<p><i>FunctionTypeExpression</i> : <b>(</b> <i>FunctionTypeParameters</i> <b>)</b> <b>=&gt;</b> <i>TypeExpression</i></p>
<ul>
<li>It is a verify error if <i>FunctionTypeParameters</i> is not a sequence of zero or more <i>TypedIdentifier</i> followed by zero or more <i>FunctionTypeOptionalParameter</i> followed by optional <b>...</b> <i>TypedIdentifier</i>.</li>
<li>Let <em>p</em><sub>0</sub> be an empty list.</li>
<li>Let <em>p</em><sub>1</sub> be an empty list.</li>
<li>Let <em>p</em><sub>2</sub> be undefined.</li>
<li>For each <i>TypedIdentifier</i> as <em>typedId</em> in <i>FunctionTypeParameters</i>
<ul>
<li>Let (<em>name</em>, <em>type</em>) be the verification of <em>typedId</em>.</li>
<li>Contribute (<em>name</em>, <em>type</em>) to <em>p</em><sub>0</sub>.</li>
</ul>
</li>
<li>For each <i>FunctionTypeOptionalParameter</i> as <em>optParam</em> in <i>FunctionTypeParameters</i>
<ul>
<li>Let (<em>name</em>, <em>type</em>) be the verification of <em>optParam</em>.</li>
<li>Contribute (<em>name</em>, <em>type</em>) to <em>p</em><sub>1</sub>.</li>
</ul>
</li>
<li>If <i>FunctionTypeParameters</i> contains <b>...</b> <i>TypedIdentifier</i> as <em>typeId</em>
<ul>
<li>Let (<em>name</em>, <em>type</em>) be the verification of <em>typedId</em>.</li>
<li>It is a verify error if <em>type</em> is not the <code>Array</code> type.</li>
<li>Assign <em>p</em><sub>2</sub> = (<em>name</em>, <em>type</em>)</li>
</ul>
</li>
<li>Let <em>returnType</em> be the verification of <i>TypeExpression</i> preceded by <b>=&gt;</b>.</li>
<li>Return a function type consisting of required parameters <em>p</em><sub>0</sub>, optional parameters <em>p</em><sub>1</sub>, rest parameter <em>p</em><sub>2</sub> and return type <em>returnType</em>.</li>
</ul>
<p><i>TypedIdentifier</i> : <i>IdentifierName</i><br>
<i>FunctionTypeOptionalParameter</i> : <i>IdentifierName</i></p>
<ul>
<li>It is a verify error if no context type is given.</li>
<li>Return (string of <i>IdentifierName</i>, context type)</li>
</ul>
<p><i>TypedIdentifier</i> : <i>IdentifierName</i> <b>?</b> <b>:</b> <i>TypeExpression</i><br>
<i>FunctionTypeOptionalParameter</i> : <i>IdentifierName</i> <b>?</b> <b>:</b> <i>TypeExpression</i></p>
<ul>
<li>Return (string of <i>IdentifierName</i>, verification of <i>TypeExpression</i>)</li>
</ul>
<p><i>TypeArguments</i> : <b>.</b> <b>&lt;</b> <i>TypeArgumentsList</i> <b>&gt;</b><br>
<i>TypeArguments</i> : <b>.</b> <b>&lt;</b> <i>TypeArgumentsList</i> [initial <b>&gt;</b> from the offending token]</p>
<ul>
<li>Return the verification of each <i>TypeExpression</i> in <i>TypeArgumentsList</i> in a sequence.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
